// This file is generated by rust-protobuf 3.2.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `auth.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_2_0;

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:qreeket.AuthenticateWithSocialAccountRequest)
pub struct AuthenticateWithSocialAccountRequest {
    // message fields
    // @@protoc_insertion_point(field:qreeket.AuthenticateWithSocialAccountRequest.phone_number)
    pub phone_number: ::std::string::String,
    // @@protoc_insertion_point(field:qreeket.AuthenticateWithSocialAccountRequest.username)
    pub username: ::std::string::String,
    // @@protoc_insertion_point(field:qreeket.AuthenticateWithSocialAccountRequest.country_id)
    pub country_id: ::std::string::String,
    // @@protoc_insertion_point(field:qreeket.AuthenticateWithSocialAccountRequest.college_id)
    pub college_id: ::std::string::String,
    // @@protoc_insertion_point(field:qreeket.AuthenticateWithSocialAccountRequest.email)
    pub email: ::std::string::String,
    // message oneof groups
    pub auth_avatar: ::std::option::Option<authenticate_with_social_account_request::Auth_avatar>,
    // special fields
    // @@protoc_insertion_point(special_field:qreeket.AuthenticateWithSocialAccountRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AuthenticateWithSocialAccountRequest {
    fn default() -> &'a AuthenticateWithSocialAccountRequest {
        <AuthenticateWithSocialAccountRequest as ::protobuf::Message>::default_instance()
    }
}

impl AuthenticateWithSocialAccountRequest {
    pub fn new() -> AuthenticateWithSocialAccountRequest {
        ::std::default::Default::default()
    }

    // string avatar_url = 3;

    pub fn avatar_url(&self) -> &str {
        match self.auth_avatar {
            ::std::option::Option::Some(authenticate_with_social_account_request::Auth_avatar::AvatarUrl(ref v)) => v,
            _ => "",
        }
    }

    pub fn clear_avatar_url(&mut self) {
        self.auth_avatar = ::std::option::Option::None;
    }

    pub fn has_avatar_url(&self) -> bool {
        match self.auth_avatar {
            ::std::option::Option::Some(authenticate_with_social_account_request::Auth_avatar::AvatarUrl(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_avatar_url(&mut self, v: ::std::string::String) {
        self.auth_avatar = ::std::option::Option::Some(authenticate_with_social_account_request::Auth_avatar::AvatarUrl(v))
    }

    // Mutable pointer to the field.
    pub fn mut_avatar_url(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(authenticate_with_social_account_request::Auth_avatar::AvatarUrl(_)) = self.auth_avatar {
        } else {
            self.auth_avatar = ::std::option::Option::Some(authenticate_with_social_account_request::Auth_avatar::AvatarUrl(::std::string::String::new()));
        }
        match self.auth_avatar {
            ::std::option::Option::Some(authenticate_with_social_account_request::Auth_avatar::AvatarUrl(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_avatar_url(&mut self) -> ::std::string::String {
        if self.has_avatar_url() {
            match self.auth_avatar.take() {
                ::std::option::Option::Some(authenticate_with_social_account_request::Auth_avatar::AvatarUrl(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // bytes avatar_data = 4;

    pub fn avatar_data(&self) -> &[u8] {
        match self.auth_avatar {
            ::std::option::Option::Some(authenticate_with_social_account_request::Auth_avatar::AvatarData(ref v)) => v,
            _ => &[],
        }
    }

    pub fn clear_avatar_data(&mut self) {
        self.auth_avatar = ::std::option::Option::None;
    }

    pub fn has_avatar_data(&self) -> bool {
        match self.auth_avatar {
            ::std::option::Option::Some(authenticate_with_social_account_request::Auth_avatar::AvatarData(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_avatar_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.auth_avatar = ::std::option::Option::Some(authenticate_with_social_account_request::Auth_avatar::AvatarData(v))
    }

    // Mutable pointer to the field.
    pub fn mut_avatar_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if let ::std::option::Option::Some(authenticate_with_social_account_request::Auth_avatar::AvatarData(_)) = self.auth_avatar {
        } else {
            self.auth_avatar = ::std::option::Option::Some(authenticate_with_social_account_request::Auth_avatar::AvatarData(::std::vec::Vec::new()));
        }
        match self.auth_avatar {
            ::std::option::Option::Some(authenticate_with_social_account_request::Auth_avatar::AvatarData(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_avatar_data(&mut self) -> ::std::vec::Vec<u8> {
        if self.has_avatar_data() {
            match self.auth_avatar.take() {
                ::std::option::Option::Some(authenticate_with_social_account_request::Auth_avatar::AvatarData(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::vec::Vec::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "phone_number",
            |m: &AuthenticateWithSocialAccountRequest| { &m.phone_number },
            |m: &mut AuthenticateWithSocialAccountRequest| { &mut m.phone_number },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "username",
            |m: &AuthenticateWithSocialAccountRequest| { &m.username },
            |m: &mut AuthenticateWithSocialAccountRequest| { &mut m.username },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_deref_has_get_set_simpler_accessor::<_, _>(
            "avatar_url",
            AuthenticateWithSocialAccountRequest::has_avatar_url,
            AuthenticateWithSocialAccountRequest::avatar_url,
            AuthenticateWithSocialAccountRequest::set_avatar_url,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_deref_has_get_set_simpler_accessor::<_, _>(
            "avatar_data",
            AuthenticateWithSocialAccountRequest::has_avatar_data,
            AuthenticateWithSocialAccountRequest::avatar_data,
            AuthenticateWithSocialAccountRequest::set_avatar_data,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "country_id",
            |m: &AuthenticateWithSocialAccountRequest| { &m.country_id },
            |m: &mut AuthenticateWithSocialAccountRequest| { &mut m.country_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "college_id",
            |m: &AuthenticateWithSocialAccountRequest| { &m.college_id },
            |m: &mut AuthenticateWithSocialAccountRequest| { &mut m.college_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "email",
            |m: &AuthenticateWithSocialAccountRequest| { &m.email },
            |m: &mut AuthenticateWithSocialAccountRequest| { &mut m.email },
        ));
        oneofs.push(authenticate_with_social_account_request::Auth_avatar::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AuthenticateWithSocialAccountRequest>(
            "AuthenticateWithSocialAccountRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AuthenticateWithSocialAccountRequest {
    const NAME: &'static str = "AuthenticateWithSocialAccountRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.phone_number = is.read_string()?;
                },
                18 => {
                    self.username = is.read_string()?;
                },
                26 => {
                    self.auth_avatar = ::std::option::Option::Some(authenticate_with_social_account_request::Auth_avatar::AvatarUrl(is.read_string()?));
                },
                34 => {
                    self.auth_avatar = ::std::option::Option::Some(authenticate_with_social_account_request::Auth_avatar::AvatarData(is.read_bytes()?));
                },
                42 => {
                    self.country_id = is.read_string()?;
                },
                50 => {
                    self.college_id = is.read_string()?;
                },
                58 => {
                    self.email = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.phone_number.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.phone_number);
        }
        if !self.username.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.username);
        }
        if !self.country_id.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.country_id);
        }
        if !self.college_id.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.college_id);
        }
        if !self.email.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.email);
        }
        if let ::std::option::Option::Some(ref v) = self.auth_avatar {
            match v {
                &authenticate_with_social_account_request::Auth_avatar::AvatarUrl(ref v) => {
                    my_size += ::protobuf::rt::string_size(3, &v);
                },
                &authenticate_with_social_account_request::Auth_avatar::AvatarData(ref v) => {
                    my_size += ::protobuf::rt::bytes_size(4, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.phone_number.is_empty() {
            os.write_string(1, &self.phone_number)?;
        }
        if !self.username.is_empty() {
            os.write_string(2, &self.username)?;
        }
        if !self.country_id.is_empty() {
            os.write_string(5, &self.country_id)?;
        }
        if !self.college_id.is_empty() {
            os.write_string(6, &self.college_id)?;
        }
        if !self.email.is_empty() {
            os.write_string(7, &self.email)?;
        }
        if let ::std::option::Option::Some(ref v) = self.auth_avatar {
            match v {
                &authenticate_with_social_account_request::Auth_avatar::AvatarUrl(ref v) => {
                    os.write_string(3, v)?;
                },
                &authenticate_with_social_account_request::Auth_avatar::AvatarData(ref v) => {
                    os.write_bytes(4, v)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AuthenticateWithSocialAccountRequest {
        AuthenticateWithSocialAccountRequest::new()
    }

    fn clear(&mut self) {
        self.phone_number.clear();
        self.username.clear();
        self.auth_avatar = ::std::option::Option::None;
        self.auth_avatar = ::std::option::Option::None;
        self.country_id.clear();
        self.college_id.clear();
        self.email.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AuthenticateWithSocialAccountRequest {
        static instance: AuthenticateWithSocialAccountRequest = AuthenticateWithSocialAccountRequest {
            phone_number: ::std::string::String::new(),
            username: ::std::string::String::new(),
            country_id: ::std::string::String::new(),
            college_id: ::std::string::String::new(),
            email: ::std::string::String::new(),
            auth_avatar: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AuthenticateWithSocialAccountRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AuthenticateWithSocialAccountRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AuthenticateWithSocialAccountRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AuthenticateWithSocialAccountRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `AuthenticateWithSocialAccountRequest`
pub mod authenticate_with_social_account_request {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:qreeket.AuthenticateWithSocialAccountRequest.auth_avatar)
    pub enum Auth_avatar {
        // @@protoc_insertion_point(oneof_field:qreeket.AuthenticateWithSocialAccountRequest.avatar_url)
        AvatarUrl(::std::string::String),
        // @@protoc_insertion_point(oneof_field:qreeket.AuthenticateWithSocialAccountRequest.avatar_data)
        AvatarData(::std::vec::Vec<u8>),
    }

    impl ::protobuf::Oneof for Auth_avatar {
    }

    impl ::protobuf::OneofFull for Auth_avatar {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::AuthenticateWithSocialAccountRequest as ::protobuf::MessageFull>::descriptor().oneof_by_name("auth_avatar").unwrap()).clone()
        }
    }

    impl Auth_avatar {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Auth_avatar>("auth_avatar")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:qreeket.GetCollegesResponse)
pub struct GetCollegesResponse {
    // message fields
    // @@protoc_insertion_point(field:qreeket.GetCollegesResponse.colleges)
    pub colleges: ::std::vec::Vec<College>,
    // special fields
    // @@protoc_insertion_point(special_field:qreeket.GetCollegesResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetCollegesResponse {
    fn default() -> &'a GetCollegesResponse {
        <GetCollegesResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetCollegesResponse {
    pub fn new() -> GetCollegesResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "colleges",
            |m: &GetCollegesResponse| { &m.colleges },
            |m: &mut GetCollegesResponse| { &mut m.colleges },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetCollegesResponse>(
            "GetCollegesResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetCollegesResponse {
    const NAME: &'static str = "GetCollegesResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.colleges.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.colleges {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.colleges {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetCollegesResponse {
        GetCollegesResponse::new()
    }

    fn clear(&mut self) {
        self.colleges.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetCollegesResponse {
        static instance: GetCollegesResponse = GetCollegesResponse {
            colleges: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetCollegesResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetCollegesResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetCollegesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetCollegesResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:qreeket.GetCountriesResponse)
pub struct GetCountriesResponse {
    // message fields
    // @@protoc_insertion_point(field:qreeket.GetCountriesResponse.countries)
    pub countries: ::std::vec::Vec<Country>,
    // special fields
    // @@protoc_insertion_point(special_field:qreeket.GetCountriesResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetCountriesResponse {
    fn default() -> &'a GetCountriesResponse {
        <GetCountriesResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetCountriesResponse {
    pub fn new() -> GetCountriesResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "countries",
            |m: &GetCountriesResponse| { &m.countries },
            |m: &mut GetCountriesResponse| { &mut m.countries },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetCountriesResponse>(
            "GetCountriesResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetCountriesResponse {
    const NAME: &'static str = "GetCountriesResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.countries.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.countries {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.countries {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetCountriesResponse {
        GetCountriesResponse::new()
    }

    fn clear(&mut self) {
        self.countries.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetCountriesResponse {
        static instance: GetCountriesResponse = GetCountriesResponse {
            countries: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetCountriesResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetCountriesResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetCountriesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetCountriesResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  validate access token response message
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:qreeket.ValidateAccessTokenResponse)
pub struct ValidateAccessTokenResponse {
    // message fields
    // @@protoc_insertion_point(field:qreeket.ValidateAccessTokenResponse.account_id)
    pub account_id: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:qreeket.ValidateAccessTokenResponse.phone_number)
    pub phone_number: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:qreeket.ValidateAccessTokenResponse.username)
    pub username: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:qreeket.ValidateAccessTokenResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ValidateAccessTokenResponse {
    fn default() -> &'a ValidateAccessTokenResponse {
        <ValidateAccessTokenResponse as ::protobuf::Message>::default_instance()
    }
}

impl ValidateAccessTokenResponse {
    pub fn new() -> ValidateAccessTokenResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_id",
            |m: &ValidateAccessTokenResponse| { &m.account_id },
            |m: &mut ValidateAccessTokenResponse| { &mut m.account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "phone_number",
            |m: &ValidateAccessTokenResponse| { &m.phone_number },
            |m: &mut ValidateAccessTokenResponse| { &mut m.phone_number },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "username",
            |m: &ValidateAccessTokenResponse| { &m.username },
            |m: &mut ValidateAccessTokenResponse| { &mut m.username },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ValidateAccessTokenResponse>(
            "ValidateAccessTokenResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ValidateAccessTokenResponse {
    const NAME: &'static str = "ValidateAccessTokenResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.account_id = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.phone_number = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.username = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.phone_number.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.username.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.account_id.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.phone_number.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.username.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ValidateAccessTokenResponse {
        ValidateAccessTokenResponse::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.phone_number = ::std::option::Option::None;
        self.username = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ValidateAccessTokenResponse {
        static instance: ValidateAccessTokenResponse = ValidateAccessTokenResponse {
            account_id: ::std::option::Option::None,
            phone_number: ::std::option::Option::None,
            username: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ValidateAccessTokenResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ValidateAccessTokenResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ValidateAccessTokenResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ValidateAccessTokenResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  login request message
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:qreeket.LoginRequest)
pub struct LoginRequest {
    // message fields
    // @@protoc_insertion_point(field:qreeket.LoginRequest.password)
    pub password: ::std::string::String,
    // @@protoc_insertion_point(field:qreeket.LoginRequest.country_id)
    pub country_id: ::std::string::String,
    // message oneof groups
    pub payload: ::std::option::Option<login_request::Payload>,
    // special fields
    // @@protoc_insertion_point(special_field:qreeket.LoginRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LoginRequest {
    fn default() -> &'a LoginRequest {
        <LoginRequest as ::protobuf::Message>::default_instance()
    }
}

impl LoginRequest {
    pub fn new() -> LoginRequest {
        ::std::default::Default::default()
    }

    // string phone_number = 1;

    pub fn phone_number(&self) -> &str {
        match self.payload {
            ::std::option::Option::Some(login_request::Payload::PhoneNumber(ref v)) => v,
            _ => "",
        }
    }

    pub fn clear_phone_number(&mut self) {
        self.payload = ::std::option::Option::None;
    }

    pub fn has_phone_number(&self) -> bool {
        match self.payload {
            ::std::option::Option::Some(login_request::Payload::PhoneNumber(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_phone_number(&mut self, v: ::std::string::String) {
        self.payload = ::std::option::Option::Some(login_request::Payload::PhoneNumber(v))
    }

    // Mutable pointer to the field.
    pub fn mut_phone_number(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(login_request::Payload::PhoneNumber(_)) = self.payload {
        } else {
            self.payload = ::std::option::Option::Some(login_request::Payload::PhoneNumber(::std::string::String::new()));
        }
        match self.payload {
            ::std::option::Option::Some(login_request::Payload::PhoneNumber(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_phone_number(&mut self) -> ::std::string::String {
        if self.has_phone_number() {
            match self.payload.take() {
                ::std::option::Option::Some(login_request::Payload::PhoneNumber(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // string email = 2;

    pub fn email(&self) -> &str {
        match self.payload {
            ::std::option::Option::Some(login_request::Payload::Email(ref v)) => v,
            _ => "",
        }
    }

    pub fn clear_email(&mut self) {
        self.payload = ::std::option::Option::None;
    }

    pub fn has_email(&self) -> bool {
        match self.payload {
            ::std::option::Option::Some(login_request::Payload::Email(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_email(&mut self, v: ::std::string::String) {
        self.payload = ::std::option::Option::Some(login_request::Payload::Email(v))
    }

    // Mutable pointer to the field.
    pub fn mut_email(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(login_request::Payload::Email(_)) = self.payload {
        } else {
            self.payload = ::std::option::Option::Some(login_request::Payload::Email(::std::string::String::new()));
        }
        match self.payload {
            ::std::option::Option::Some(login_request::Payload::Email(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_email(&mut self) -> ::std::string::String {
        if self.has_email() {
            match self.payload.take() {
                ::std::option::Option::Some(login_request::Payload::Email(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_deref_has_get_set_simpler_accessor::<_, _>(
            "phone_number",
            LoginRequest::has_phone_number,
            LoginRequest::phone_number,
            LoginRequest::set_phone_number,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_deref_has_get_set_simpler_accessor::<_, _>(
            "email",
            LoginRequest::has_email,
            LoginRequest::email,
            LoginRequest::set_email,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "password",
            |m: &LoginRequest| { &m.password },
            |m: &mut LoginRequest| { &mut m.password },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "country_id",
            |m: &LoginRequest| { &m.country_id },
            |m: &mut LoginRequest| { &mut m.country_id },
        ));
        oneofs.push(login_request::Payload::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LoginRequest>(
            "LoginRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LoginRequest {
    const NAME: &'static str = "LoginRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.payload = ::std::option::Option::Some(login_request::Payload::PhoneNumber(is.read_string()?));
                },
                18 => {
                    self.payload = ::std::option::Option::Some(login_request::Payload::Email(is.read_string()?));
                },
                26 => {
                    self.password = is.read_string()?;
                },
                34 => {
                    self.country_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.password.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.password);
        }
        if !self.country_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.country_id);
        }
        if let ::std::option::Option::Some(ref v) = self.payload {
            match v {
                &login_request::Payload::PhoneNumber(ref v) => {
                    my_size += ::protobuf::rt::string_size(1, &v);
                },
                &login_request::Payload::Email(ref v) => {
                    my_size += ::protobuf::rt::string_size(2, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.password.is_empty() {
            os.write_string(3, &self.password)?;
        }
        if !self.country_id.is_empty() {
            os.write_string(4, &self.country_id)?;
        }
        if let ::std::option::Option::Some(ref v) = self.payload {
            match v {
                &login_request::Payload::PhoneNumber(ref v) => {
                    os.write_string(1, v)?;
                },
                &login_request::Payload::Email(ref v) => {
                    os.write_string(2, v)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LoginRequest {
        LoginRequest::new()
    }

    fn clear(&mut self) {
        self.payload = ::std::option::Option::None;
        self.payload = ::std::option::Option::None;
        self.password.clear();
        self.country_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LoginRequest {
        static instance: LoginRequest = LoginRequest {
            password: ::std::string::String::new(),
            country_id: ::std::string::String::new(),
            payload: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LoginRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LoginRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LoginRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LoginRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `LoginRequest`
pub mod login_request {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:qreeket.LoginRequest.payload)
    pub enum Payload {
        // @@protoc_insertion_point(oneof_field:qreeket.LoginRequest.phone_number)
        PhoneNumber(::std::string::String),
        // @@protoc_insertion_point(oneof_field:qreeket.LoginRequest.email)
        Email(::std::string::String),
    }

    impl ::protobuf::Oneof for Payload {
    }

    impl ::protobuf::OneofFull for Payload {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::LoginRequest as ::protobuf::MessageFull>::descriptor().oneof_by_name("payload").unwrap()).clone()
        }
    }

    impl Payload {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Payload>("payload")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:qreeket.RegisterRequest)
pub struct RegisterRequest {
    // message fields
    // @@protoc_insertion_point(field:qreeket.RegisterRequest.phone_number)
    pub phone_number: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:qreeket.RegisterRequest.password)
    pub password: ::std::string::String,
    // @@protoc_insertion_point(field:qreeket.RegisterRequest.username)
    pub username: ::std::string::String,
    // @@protoc_insertion_point(field:qreeket.RegisterRequest.country_id)
    pub country_id: ::std::string::String,
    // @@protoc_insertion_point(field:qreeket.RegisterRequest.college_id)
    pub college_id: ::std::string::String,
    // @@protoc_insertion_point(field:qreeket.RegisterRequest.email)
    pub email: ::std::option::Option<::std::string::String>,
    // message oneof groups
    pub avatar: ::std::option::Option<register_request::Avatar>,
    // special fields
    // @@protoc_insertion_point(special_field:qreeket.RegisterRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RegisterRequest {
    fn default() -> &'a RegisterRequest {
        <RegisterRequest as ::protobuf::Message>::default_instance()
    }
}

impl RegisterRequest {
    pub fn new() -> RegisterRequest {
        ::std::default::Default::default()
    }

    // string avatar_url = 5;

    pub fn avatar_url(&self) -> &str {
        match self.avatar {
            ::std::option::Option::Some(register_request::Avatar::AvatarUrl(ref v)) => v,
            _ => "",
        }
    }

    pub fn clear_avatar_url(&mut self) {
        self.avatar = ::std::option::Option::None;
    }

    pub fn has_avatar_url(&self) -> bool {
        match self.avatar {
            ::std::option::Option::Some(register_request::Avatar::AvatarUrl(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_avatar_url(&mut self, v: ::std::string::String) {
        self.avatar = ::std::option::Option::Some(register_request::Avatar::AvatarUrl(v))
    }

    // Mutable pointer to the field.
    pub fn mut_avatar_url(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(register_request::Avatar::AvatarUrl(_)) = self.avatar {
        } else {
            self.avatar = ::std::option::Option::Some(register_request::Avatar::AvatarUrl(::std::string::String::new()));
        }
        match self.avatar {
            ::std::option::Option::Some(register_request::Avatar::AvatarUrl(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_avatar_url(&mut self) -> ::std::string::String {
        if self.has_avatar_url() {
            match self.avatar.take() {
                ::std::option::Option::Some(register_request::Avatar::AvatarUrl(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // bytes avatar_data = 6;

    pub fn avatar_data(&self) -> &[u8] {
        match self.avatar {
            ::std::option::Option::Some(register_request::Avatar::AvatarData(ref v)) => v,
            _ => &[],
        }
    }

    pub fn clear_avatar_data(&mut self) {
        self.avatar = ::std::option::Option::None;
    }

    pub fn has_avatar_data(&self) -> bool {
        match self.avatar {
            ::std::option::Option::Some(register_request::Avatar::AvatarData(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_avatar_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.avatar = ::std::option::Option::Some(register_request::Avatar::AvatarData(v))
    }

    // Mutable pointer to the field.
    pub fn mut_avatar_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if let ::std::option::Option::Some(register_request::Avatar::AvatarData(_)) = self.avatar {
        } else {
            self.avatar = ::std::option::Option::Some(register_request::Avatar::AvatarData(::std::vec::Vec::new()));
        }
        match self.avatar {
            ::std::option::Option::Some(register_request::Avatar::AvatarData(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_avatar_data(&mut self) -> ::std::vec::Vec<u8> {
        if self.has_avatar_data() {
            match self.avatar.take() {
                ::std::option::Option::Some(register_request::Avatar::AvatarData(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::vec::Vec::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "phone_number",
            |m: &RegisterRequest| { &m.phone_number },
            |m: &mut RegisterRequest| { &mut m.phone_number },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "password",
            |m: &RegisterRequest| { &m.password },
            |m: &mut RegisterRequest| { &mut m.password },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "username",
            |m: &RegisterRequest| { &m.username },
            |m: &mut RegisterRequest| { &mut m.username },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_deref_has_get_set_simpler_accessor::<_, _>(
            "avatar_url",
            RegisterRequest::has_avatar_url,
            RegisterRequest::avatar_url,
            RegisterRequest::set_avatar_url,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_deref_has_get_set_simpler_accessor::<_, _>(
            "avatar_data",
            RegisterRequest::has_avatar_data,
            RegisterRequest::avatar_data,
            RegisterRequest::set_avatar_data,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "country_id",
            |m: &RegisterRequest| { &m.country_id },
            |m: &mut RegisterRequest| { &mut m.country_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "college_id",
            |m: &RegisterRequest| { &m.college_id },
            |m: &mut RegisterRequest| { &mut m.college_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "email",
            |m: &RegisterRequest| { &m.email },
            |m: &mut RegisterRequest| { &mut m.email },
        ));
        oneofs.push(register_request::Avatar::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RegisterRequest>(
            "RegisterRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RegisterRequest {
    const NAME: &'static str = "RegisterRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.phone_number = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.password = is.read_string()?;
                },
                34 => {
                    self.username = is.read_string()?;
                },
                42 => {
                    self.avatar = ::std::option::Option::Some(register_request::Avatar::AvatarUrl(is.read_string()?));
                },
                50 => {
                    self.avatar = ::std::option::Option::Some(register_request::Avatar::AvatarData(is.read_bytes()?));
                },
                74 => {
                    self.country_id = is.read_string()?;
                },
                82 => {
                    self.college_id = is.read_string()?;
                },
                90 => {
                    self.email = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.phone_number.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if !self.password.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.password);
        }
        if !self.username.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.username);
        }
        if !self.country_id.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.country_id);
        }
        if !self.college_id.is_empty() {
            my_size += ::protobuf::rt::string_size(10, &self.college_id);
        }
        if let Some(v) = self.email.as_ref() {
            my_size += ::protobuf::rt::string_size(11, &v);
        }
        if let ::std::option::Option::Some(ref v) = self.avatar {
            match v {
                &register_request::Avatar::AvatarUrl(ref v) => {
                    my_size += ::protobuf::rt::string_size(5, &v);
                },
                &register_request::Avatar::AvatarData(ref v) => {
                    my_size += ::protobuf::rt::bytes_size(6, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.phone_number.as_ref() {
            os.write_string(1, v)?;
        }
        if !self.password.is_empty() {
            os.write_string(2, &self.password)?;
        }
        if !self.username.is_empty() {
            os.write_string(4, &self.username)?;
        }
        if !self.country_id.is_empty() {
            os.write_string(9, &self.country_id)?;
        }
        if !self.college_id.is_empty() {
            os.write_string(10, &self.college_id)?;
        }
        if let Some(v) = self.email.as_ref() {
            os.write_string(11, v)?;
        }
        if let ::std::option::Option::Some(ref v) = self.avatar {
            match v {
                &register_request::Avatar::AvatarUrl(ref v) => {
                    os.write_string(5, v)?;
                },
                &register_request::Avatar::AvatarData(ref v) => {
                    os.write_bytes(6, v)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RegisterRequest {
        RegisterRequest::new()
    }

    fn clear(&mut self) {
        self.phone_number = ::std::option::Option::None;
        self.password.clear();
        self.username.clear();
        self.avatar = ::std::option::Option::None;
        self.avatar = ::std::option::Option::None;
        self.country_id.clear();
        self.college_id.clear();
        self.email = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RegisterRequest {
        static instance: RegisterRequest = RegisterRequest {
            phone_number: ::std::option::Option::None,
            password: ::std::string::String::new(),
            username: ::std::string::String::new(),
            country_id: ::std::string::String::new(),
            college_id: ::std::string::String::new(),
            email: ::std::option::Option::None,
            avatar: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RegisterRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RegisterRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RegisterRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RegisterRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `RegisterRequest`
pub mod register_request {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:qreeket.RegisterRequest.avatar)
    pub enum Avatar {
        // @@protoc_insertion_point(oneof_field:qreeket.RegisterRequest.avatar_url)
        AvatarUrl(::std::string::String),
        // @@protoc_insertion_point(oneof_field:qreeket.RegisterRequest.avatar_data)
        AvatarData(::std::vec::Vec<u8>),
    }

    impl ::protobuf::Oneof for Avatar {
    }

    impl ::protobuf::OneofFull for Avatar {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::RegisterRequest as ::protobuf::MessageFull>::descriptor().oneof_by_name("avatar").unwrap()).clone()
        }
    }

    impl Avatar {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Avatar>("avatar")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:qreeket.ResetPasswordRequest)
pub struct ResetPasswordRequest {
    // message fields
    // @@protoc_insertion_point(field:qreeket.ResetPasswordRequest.password)
    pub password: ::std::string::String,
    // message oneof groups
    pub reset_payload: ::std::option::Option<reset_password_request::Reset_payload>,
    // special fields
    // @@protoc_insertion_point(special_field:qreeket.ResetPasswordRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ResetPasswordRequest {
    fn default() -> &'a ResetPasswordRequest {
        <ResetPasswordRequest as ::protobuf::Message>::default_instance()
    }
}

impl ResetPasswordRequest {
    pub fn new() -> ResetPasswordRequest {
        ::std::default::Default::default()
    }

    // string phone_number = 1;

    pub fn phone_number(&self) -> &str {
        match self.reset_payload {
            ::std::option::Option::Some(reset_password_request::Reset_payload::PhoneNumber(ref v)) => v,
            _ => "",
        }
    }

    pub fn clear_phone_number(&mut self) {
        self.reset_payload = ::std::option::Option::None;
    }

    pub fn has_phone_number(&self) -> bool {
        match self.reset_payload {
            ::std::option::Option::Some(reset_password_request::Reset_payload::PhoneNumber(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_phone_number(&mut self, v: ::std::string::String) {
        self.reset_payload = ::std::option::Option::Some(reset_password_request::Reset_payload::PhoneNumber(v))
    }

    // Mutable pointer to the field.
    pub fn mut_phone_number(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(reset_password_request::Reset_payload::PhoneNumber(_)) = self.reset_payload {
        } else {
            self.reset_payload = ::std::option::Option::Some(reset_password_request::Reset_payload::PhoneNumber(::std::string::String::new()));
        }
        match self.reset_payload {
            ::std::option::Option::Some(reset_password_request::Reset_payload::PhoneNumber(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_phone_number(&mut self) -> ::std::string::String {
        if self.has_phone_number() {
            match self.reset_payload.take() {
                ::std::option::Option::Some(reset_password_request::Reset_payload::PhoneNumber(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // string email = 2;

    pub fn email(&self) -> &str {
        match self.reset_payload {
            ::std::option::Option::Some(reset_password_request::Reset_payload::Email(ref v)) => v,
            _ => "",
        }
    }

    pub fn clear_email(&mut self) {
        self.reset_payload = ::std::option::Option::None;
    }

    pub fn has_email(&self) -> bool {
        match self.reset_payload {
            ::std::option::Option::Some(reset_password_request::Reset_payload::Email(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_email(&mut self, v: ::std::string::String) {
        self.reset_payload = ::std::option::Option::Some(reset_password_request::Reset_payload::Email(v))
    }

    // Mutable pointer to the field.
    pub fn mut_email(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(reset_password_request::Reset_payload::Email(_)) = self.reset_payload {
        } else {
            self.reset_payload = ::std::option::Option::Some(reset_password_request::Reset_payload::Email(::std::string::String::new()));
        }
        match self.reset_payload {
            ::std::option::Option::Some(reset_password_request::Reset_payload::Email(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_email(&mut self) -> ::std::string::String {
        if self.has_email() {
            match self.reset_payload.take() {
                ::std::option::Option::Some(reset_password_request::Reset_payload::Email(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_deref_has_get_set_simpler_accessor::<_, _>(
            "phone_number",
            ResetPasswordRequest::has_phone_number,
            ResetPasswordRequest::phone_number,
            ResetPasswordRequest::set_phone_number,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_deref_has_get_set_simpler_accessor::<_, _>(
            "email",
            ResetPasswordRequest::has_email,
            ResetPasswordRequest::email,
            ResetPasswordRequest::set_email,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "password",
            |m: &ResetPasswordRequest| { &m.password },
            |m: &mut ResetPasswordRequest| { &mut m.password },
        ));
        oneofs.push(reset_password_request::Reset_payload::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ResetPasswordRequest>(
            "ResetPasswordRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ResetPasswordRequest {
    const NAME: &'static str = "ResetPasswordRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.reset_payload = ::std::option::Option::Some(reset_password_request::Reset_payload::PhoneNumber(is.read_string()?));
                },
                18 => {
                    self.reset_payload = ::std::option::Option::Some(reset_password_request::Reset_payload::Email(is.read_string()?));
                },
                34 => {
                    self.password = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.password.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.password);
        }
        if let ::std::option::Option::Some(ref v) = self.reset_payload {
            match v {
                &reset_password_request::Reset_payload::PhoneNumber(ref v) => {
                    my_size += ::protobuf::rt::string_size(1, &v);
                },
                &reset_password_request::Reset_payload::Email(ref v) => {
                    my_size += ::protobuf::rt::string_size(2, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.password.is_empty() {
            os.write_string(4, &self.password)?;
        }
        if let ::std::option::Option::Some(ref v) = self.reset_payload {
            match v {
                &reset_password_request::Reset_payload::PhoneNumber(ref v) => {
                    os.write_string(1, v)?;
                },
                &reset_password_request::Reset_payload::Email(ref v) => {
                    os.write_string(2, v)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ResetPasswordRequest {
        ResetPasswordRequest::new()
    }

    fn clear(&mut self) {
        self.reset_payload = ::std::option::Option::None;
        self.reset_payload = ::std::option::Option::None;
        self.password.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ResetPasswordRequest {
        static instance: ResetPasswordRequest = ResetPasswordRequest {
            password: ::std::string::String::new(),
            reset_payload: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ResetPasswordRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ResetPasswordRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ResetPasswordRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResetPasswordRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ResetPasswordRequest`
pub mod reset_password_request {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:qreeket.ResetPasswordRequest.reset_payload)
    pub enum Reset_payload {
        // @@protoc_insertion_point(oneof_field:qreeket.ResetPasswordRequest.phone_number)
        PhoneNumber(::std::string::String),
        // @@protoc_insertion_point(oneof_field:qreeket.ResetPasswordRequest.email)
        Email(::std::string::String),
    }

    impl ::protobuf::Oneof for Reset_payload {
    }

    impl ::protobuf::OneofFull for Reset_payload {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::ResetPasswordRequest as ::protobuf::MessageFull>::descriptor().oneof_by_name("reset_payload").unwrap()).clone()
        }
    }

    impl Reset_payload {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Reset_payload>("reset_payload")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:qreeket.Account)
pub struct Account {
    // message fields
    // @@protoc_insertion_point(field:qreeket.Account.id)
    pub id: ::std::string::String,
    // @@protoc_insertion_point(field:qreeket.Account.phone_number)
    pub phone_number: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:qreeket.Account.username)
    pub username: ::std::string::String,
    // @@protoc_insertion_point(field:qreeket.Account.language_id)
    pub language_id: ::std::string::String,
    // @@protoc_insertion_point(field:qreeket.Account.created_at)
    pub created_at: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
    // @@protoc_insertion_point(field:qreeket.Account.updated_at)
    pub updated_at: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
    // @@protoc_insertion_point(field:qreeket.Account.avatar_url)
    pub avatar_url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:qreeket.Account.country_id)
    pub country_id: ::std::string::String,
    // @@protoc_insertion_point(field:qreeket.Account.device_id)
    pub device_id: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:qreeket.Account.device_token)
    pub device_token: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:qreeket.Account.device_type)
    pub device_type: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:qreeket.Account.is_verified)
    pub is_verified: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:qreeket.Account.user_type)
    pub user_type: ::std::option::Option<::protobuf::EnumOrUnknown<UserType>>,
    // @@protoc_insertion_point(field:qreeket.Account.college_id)
    pub college_id: ::std::string::String,
    // @@protoc_insertion_point(field:qreeket.Account.email)
    pub email: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:qreeket.Account.is_visible)
    pub is_visible: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:qreeket.Account.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Account {
    fn default() -> &'a Account {
        <Account as ::protobuf::Message>::default_instance()
    }
}

impl Account {
    pub fn new() -> Account {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(16);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &Account| { &m.id },
            |m: &mut Account| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "phone_number",
            |m: &Account| { &m.phone_number },
            |m: &mut Account| { &mut m.phone_number },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "username",
            |m: &Account| { &m.username },
            |m: &mut Account| { &mut m.username },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "language_id",
            |m: &Account| { &m.language_id },
            |m: &mut Account| { &mut m.language_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
            "created_at",
            |m: &Account| { &m.created_at },
            |m: &mut Account| { &mut m.created_at },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
            "updated_at",
            |m: &Account| { &m.updated_at },
            |m: &mut Account| { &mut m.updated_at },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "avatar_url",
            |m: &Account| { &m.avatar_url },
            |m: &mut Account| { &mut m.avatar_url },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "country_id",
            |m: &Account| { &m.country_id },
            |m: &mut Account| { &mut m.country_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "device_id",
            |m: &Account| { &m.device_id },
            |m: &mut Account| { &mut m.device_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "device_token",
            |m: &Account| { &m.device_token },
            |m: &mut Account| { &mut m.device_token },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "device_type",
            |m: &Account| { &m.device_type },
            |m: &mut Account| { &mut m.device_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_verified",
            |m: &Account| { &m.is_verified },
            |m: &mut Account| { &mut m.is_verified },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "user_type",
            |m: &Account| { &m.user_type },
            |m: &mut Account| { &mut m.user_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "college_id",
            |m: &Account| { &m.college_id },
            |m: &mut Account| { &mut m.college_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "email",
            |m: &Account| { &m.email },
            |m: &mut Account| { &mut m.email },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_visible",
            |m: &Account| { &m.is_visible },
            |m: &mut Account| { &mut m.is_visible },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Account>(
            "Account",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Account {
    const NAME: &'static str = "Account";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                18 => {
                    self.phone_number = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.username = is.read_string()?;
                },
                34 => {
                    self.language_id = is.read_string()?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.created_at)?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.updated_at)?;
                },
                58 => {
                    self.avatar_url = ::std::option::Option::Some(is.read_string()?);
                },
                74 => {
                    self.country_id = is.read_string()?;
                },
                82 => {
                    self.device_id = ::std::option::Option::Some(is.read_string()?);
                },
                90 => {
                    self.device_token = ::std::option::Option::Some(is.read_string()?);
                },
                98 => {
                    self.device_type = ::std::option::Option::Some(is.read_string()?);
                },
                104 => {
                    self.is_verified = ::std::option::Option::Some(is.read_bool()?);
                },
                112 => {
                    self.user_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                122 => {
                    self.college_id = is.read_string()?;
                },
                130 => {
                    self.email = ::std::option::Option::Some(is.read_string()?);
                },
                136 => {
                    self.is_visible = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if let Some(v) = self.phone_number.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if !self.username.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.username);
        }
        if !self.language_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.language_id);
        }
        if let Some(v) = self.created_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.updated_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.avatar_url.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if !self.country_id.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.country_id);
        }
        if let Some(v) = self.device_id.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        if let Some(v) = self.device_token.as_ref() {
            my_size += ::protobuf::rt::string_size(11, &v);
        }
        if let Some(v) = self.device_type.as_ref() {
            my_size += ::protobuf::rt::string_size(12, &v);
        }
        if let Some(v) = self.is_verified {
            my_size += 1 + 1;
        }
        if let Some(v) = self.user_type {
            my_size += ::protobuf::rt::int32_size(14, v.value());
        }
        if !self.college_id.is_empty() {
            my_size += ::protobuf::rt::string_size(15, &self.college_id);
        }
        if let Some(v) = self.email.as_ref() {
            my_size += ::protobuf::rt::string_size(16, &v);
        }
        if let Some(v) = self.is_visible {
            my_size += 2 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if let Some(v) = self.phone_number.as_ref() {
            os.write_string(2, v)?;
        }
        if !self.username.is_empty() {
            os.write_string(3, &self.username)?;
        }
        if !self.language_id.is_empty() {
            os.write_string(4, &self.language_id)?;
        }
        if let Some(v) = self.created_at.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.updated_at.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.avatar_url.as_ref() {
            os.write_string(7, v)?;
        }
        if !self.country_id.is_empty() {
            os.write_string(9, &self.country_id)?;
        }
        if let Some(v) = self.device_id.as_ref() {
            os.write_string(10, v)?;
        }
        if let Some(v) = self.device_token.as_ref() {
            os.write_string(11, v)?;
        }
        if let Some(v) = self.device_type.as_ref() {
            os.write_string(12, v)?;
        }
        if let Some(v) = self.is_verified {
            os.write_bool(13, v)?;
        }
        if let Some(v) = self.user_type {
            os.write_enum(14, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if !self.college_id.is_empty() {
            os.write_string(15, &self.college_id)?;
        }
        if let Some(v) = self.email.as_ref() {
            os.write_string(16, v)?;
        }
        if let Some(v) = self.is_visible {
            os.write_bool(17, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Account {
        Account::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.phone_number = ::std::option::Option::None;
        self.username.clear();
        self.language_id.clear();
        self.created_at.clear();
        self.updated_at.clear();
        self.avatar_url = ::std::option::Option::None;
        self.country_id.clear();
        self.device_id = ::std::option::Option::None;
        self.device_token = ::std::option::Option::None;
        self.device_type = ::std::option::Option::None;
        self.is_verified = ::std::option::Option::None;
        self.user_type = ::std::option::Option::None;
        self.college_id.clear();
        self.email = ::std::option::Option::None;
        self.is_visible = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Account {
        static instance: Account = Account {
            id: ::std::string::String::new(),
            phone_number: ::std::option::Option::None,
            username: ::std::string::String::new(),
            language_id: ::std::string::String::new(),
            created_at: ::protobuf::MessageField::none(),
            updated_at: ::protobuf::MessageField::none(),
            avatar_url: ::std::option::Option::None,
            country_id: ::std::string::String::new(),
            device_id: ::std::option::Option::None,
            device_token: ::std::option::Option::None,
            device_type: ::std::option::Option::None,
            is_verified: ::std::option::Option::None,
            user_type: ::std::option::Option::None,
            college_id: ::std::string::String::new(),
            email: ::std::option::Option::None,
            is_visible: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Account {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Account").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Account {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Account {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:qreeket.AccessTokenStore)
pub struct AccessTokenStore {
    // message fields
    // @@protoc_insertion_point(field:qreeket.AccessTokenStore.access_token)
    pub access_token: ::std::string::String,
    // @@protoc_insertion_point(field:qreeket.AccessTokenStore.refresh_token)
    pub refresh_token: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:qreeket.AccessTokenStore.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AccessTokenStore {
    fn default() -> &'a AccessTokenStore {
        <AccessTokenStore as ::protobuf::Message>::default_instance()
    }
}

impl AccessTokenStore {
    pub fn new() -> AccessTokenStore {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "access_token",
            |m: &AccessTokenStore| { &m.access_token },
            |m: &mut AccessTokenStore| { &mut m.access_token },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "refresh_token",
            |m: &AccessTokenStore| { &m.refresh_token },
            |m: &mut AccessTokenStore| { &mut m.refresh_token },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AccessTokenStore>(
            "AccessTokenStore",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AccessTokenStore {
    const NAME: &'static str = "AccessTokenStore";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.access_token = is.read_string()?;
                },
                26 => {
                    self.refresh_token = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.access_token.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.access_token);
        }
        if !self.refresh_token.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.refresh_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.access_token.is_empty() {
            os.write_string(1, &self.access_token)?;
        }
        if !self.refresh_token.is_empty() {
            os.write_string(3, &self.refresh_token)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AccessTokenStore {
        AccessTokenStore::new()
    }

    fn clear(&mut self) {
        self.access_token.clear();
        self.refresh_token.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AccessTokenStore {
        static instance: AccessTokenStore = AccessTokenStore {
            access_token: ::std::string::String::new(),
            refresh_token: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AccessTokenStore {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AccessTokenStore").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AccessTokenStore {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AccessTokenStore {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:qreeket.Country)
pub struct Country {
    // message fields
    // @@protoc_insertion_point(field:qreeket.Country.id)
    pub id: ::std::string::String,
    // @@protoc_insertion_point(field:qreeket.Country.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:qreeket.Country.code)
    pub code: ::std::string::String,
    // @@protoc_insertion_point(field:qreeket.Country.dial_code)
    pub dial_code: ::std::string::String,
    // @@protoc_insertion_point(field:qreeket.Country.currency)
    pub currency: ::std::string::String,
    // @@protoc_insertion_point(field:qreeket.Country.currency_symbol)
    pub currency_symbol: ::std::string::String,
    // @@protoc_insertion_point(field:qreeket.Country.flag_url)
    pub flag_url: ::std::string::String,
    // @@protoc_insertion_point(field:qreeket.Country.language_id)
    pub language_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:qreeket.Country.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Country {
    fn default() -> &'a Country {
        <Country as ::protobuf::Message>::default_instance()
    }
}

impl Country {
    pub fn new() -> Country {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &Country| { &m.id },
            |m: &mut Country| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &Country| { &m.name },
            |m: &mut Country| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "code",
            |m: &Country| { &m.code },
            |m: &mut Country| { &mut m.code },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "dial_code",
            |m: &Country| { &m.dial_code },
            |m: &mut Country| { &mut m.dial_code },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "currency",
            |m: &Country| { &m.currency },
            |m: &mut Country| { &mut m.currency },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "currency_symbol",
            |m: &Country| { &m.currency_symbol },
            |m: &mut Country| { &mut m.currency_symbol },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "flag_url",
            |m: &Country| { &m.flag_url },
            |m: &mut Country| { &mut m.flag_url },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "language_id",
            |m: &Country| { &m.language_id },
            |m: &mut Country| { &mut m.language_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Country>(
            "Country",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Country {
    const NAME: &'static str = "Country";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                18 => {
                    self.name = is.read_string()?;
                },
                26 => {
                    self.code = is.read_string()?;
                },
                34 => {
                    self.dial_code = is.read_string()?;
                },
                42 => {
                    self.currency = is.read_string()?;
                },
                50 => {
                    self.currency_symbol = is.read_string()?;
                },
                58 => {
                    self.flag_url = is.read_string()?;
                },
                66 => {
                    self.language_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        if !self.code.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.code);
        }
        if !self.dial_code.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.dial_code);
        }
        if !self.currency.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.currency);
        }
        if !self.currency_symbol.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.currency_symbol);
        }
        if !self.flag_url.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.flag_url);
        }
        if !self.language_id.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.language_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        if !self.code.is_empty() {
            os.write_string(3, &self.code)?;
        }
        if !self.dial_code.is_empty() {
            os.write_string(4, &self.dial_code)?;
        }
        if !self.currency.is_empty() {
            os.write_string(5, &self.currency)?;
        }
        if !self.currency_symbol.is_empty() {
            os.write_string(6, &self.currency_symbol)?;
        }
        if !self.flag_url.is_empty() {
            os.write_string(7, &self.flag_url)?;
        }
        if !self.language_id.is_empty() {
            os.write_string(8, &self.language_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Country {
        Country::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.name.clear();
        self.code.clear();
        self.dial_code.clear();
        self.currency.clear();
        self.currency_symbol.clear();
        self.flag_url.clear();
        self.language_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Country {
        static instance: Country = Country {
            id: ::std::string::String::new(),
            name: ::std::string::String::new(),
            code: ::std::string::String::new(),
            dial_code: ::std::string::String::new(),
            currency: ::std::string::String::new(),
            currency_symbol: ::std::string::String::new(),
            flag_url: ::std::string::String::new(),
            language_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Country {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Country").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Country {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Country {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:qreeket.College)
pub struct College {
    // message fields
    // @@protoc_insertion_point(field:qreeket.College.id)
    pub id: ::std::string::String,
    // @@protoc_insertion_point(field:qreeket.College.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:qreeket.College.address)
    pub address: ::std::string::String,
    // @@protoc_insertion_point(field:qreeket.College.logo_url)
    pub logo_url: ::std::string::String,
    // @@protoc_insertion_point(field:qreeket.College.website)
    pub website: ::std::string::String,
    // @@protoc_insertion_point(field:qreeket.College.country_id)
    pub country_id: ::std::string::String,
    // @@protoc_insertion_point(field:qreeket.College.banner_url)
    pub banner_url: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:qreeket.College.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a College {
    fn default() -> &'a College {
        <College as ::protobuf::Message>::default_instance()
    }
}

impl College {
    pub fn new() -> College {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &College| { &m.id },
            |m: &mut College| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &College| { &m.name },
            |m: &mut College| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "address",
            |m: &College| { &m.address },
            |m: &mut College| { &mut m.address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "logo_url",
            |m: &College| { &m.logo_url },
            |m: &mut College| { &mut m.logo_url },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "website",
            |m: &College| { &m.website },
            |m: &mut College| { &mut m.website },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "country_id",
            |m: &College| { &m.country_id },
            |m: &mut College| { &mut m.country_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "banner_url",
            |m: &College| { &m.banner_url },
            |m: &mut College| { &mut m.banner_url },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<College>(
            "College",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for College {
    const NAME: &'static str = "College";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                18 => {
                    self.name = is.read_string()?;
                },
                26 => {
                    self.address = is.read_string()?;
                },
                34 => {
                    self.logo_url = is.read_string()?;
                },
                42 => {
                    self.website = is.read_string()?;
                },
                50 => {
                    self.country_id = is.read_string()?;
                },
                58 => {
                    self.banner_url = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.address);
        }
        if !self.logo_url.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.logo_url);
        }
        if !self.website.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.website);
        }
        if !self.country_id.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.country_id);
        }
        if let Some(v) = self.banner_url.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        if !self.address.is_empty() {
            os.write_string(3, &self.address)?;
        }
        if !self.logo_url.is_empty() {
            os.write_string(4, &self.logo_url)?;
        }
        if !self.website.is_empty() {
            os.write_string(5, &self.website)?;
        }
        if !self.country_id.is_empty() {
            os.write_string(6, &self.country_id)?;
        }
        if let Some(v) = self.banner_url.as_ref() {
            os.write_string(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> College {
        College::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.name.clear();
        self.address.clear();
        self.logo_url.clear();
        self.website.clear();
        self.country_id.clear();
        self.banner_url = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static College {
        static instance: College = College {
            id: ::std::string::String::new(),
            name: ::std::string::String::new(),
            address: ::std::string::String::new(),
            logo_url: ::std::string::String::new(),
            website: ::std::string::String::new(),
            country_id: ::std::string::String::new(),
            banner_url: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for College {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("College").unwrap()).clone()
    }
}

impl ::std::fmt::Display for College {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for College {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:qreeket.UserType)
pub enum UserType {
    // @@protoc_insertion_point(enum_value:qreeket.UserType.standard)
    standard = 0,
    // @@protoc_insertion_point(enum_value:qreeket.UserType.premium)
    premium = 1,
}

impl ::protobuf::Enum for UserType {
    const NAME: &'static str = "UserType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<UserType> {
        match value {
            0 => ::std::option::Option::Some(UserType::standard),
            1 => ::std::option::Option::Some(UserType::premium),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [UserType] = &[
        UserType::standard,
        UserType::premium,
    ];
}

impl ::protobuf::EnumFull for UserType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("UserType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for UserType {
    fn default() -> Self {
        UserType::standard
    }
}

impl UserType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<UserType>("UserType")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\nauth.proto\x12\x07qreeket\x1a\x1fgoogle/protobuf/timestamp.proto\x1a\
    \x1bgoogle/protobuf/empty.proto\x1a\x1egoogle/protobuf/wrappers.proto\"\
    \x8c\x02\n$AuthenticateWithSocialAccountRequest\x12!\n\x0cphone_number\
    \x18\x01\x20\x01(\tR\x0bphoneNumber\x12\x1a\n\x08username\x18\x02\x20\
    \x01(\tR\x08username\x12\x1f\n\navatar_url\x18\x03\x20\x01(\tH\0R\tavata\
    rUrl\x12!\n\x0bavatar_data\x18\x04\x20\x01(\x0cH\0R\navatarData\x12\x1d\
    \n\ncountry_id\x18\x05\x20\x01(\tR\tcountryId\x12\x1d\n\ncollege_id\x18\
    \x06\x20\x01(\tR\tcollegeId\x12\x14\n\x05email\x18\x07\x20\x01(\tR\x05em\
    ailB\r\n\x0bauth_avatar\"C\n\x13GetCollegesResponse\x12,\n\x08colleges\
    \x18\x01\x20\x03(\x0b2\x10.qreeket.CollegeR\x08colleges\"F\n\x14GetCount\
    riesResponse\x12.\n\tcountries\x18\x01\x20\x03(\x0b2\x10.qreeket.Country\
    R\tcountries\"\xb7\x01\n\x1bValidateAccessTokenResponse\x12\"\n\naccount\
    _id\x18\x01\x20\x01(\tH\0R\taccountId\x88\x01\x01\x12&\n\x0cphone_number\
    \x18\x02\x20\x01(\tH\x01R\x0bphoneNumber\x88\x01\x01\x12\x1f\n\x08userna\
    me\x18\x03\x20\x01(\tH\x02R\x08username\x88\x01\x01B\r\n\x0b_account_idB\
    \x0f\n\r_phone_numberB\x0b\n\t_username\"\x91\x01\n\x0cLoginRequest\x12#\
    \n\x0cphone_number\x18\x01\x20\x01(\tH\0R\x0bphoneNumber\x12\x16\n\x05em\
    ail\x18\x02\x20\x01(\tH\0R\x05email\x12\x1a\n\x08password\x18\x03\x20\
    \x01(\tR\x08password\x12\x1d\n\ncountry_id\x18\x04\x20\x01(\tR\tcountryI\
    dB\t\n\x07payload\"\xb3\x02\n\x0fRegisterRequest\x12&\n\x0cphone_number\
    \x18\x01\x20\x01(\tH\x01R\x0bphoneNumber\x88\x01\x01\x12\x1a\n\x08passwo\
    rd\x18\x02\x20\x01(\tR\x08password\x12\x1a\n\x08username\x18\x04\x20\x01\
    (\tR\x08username\x12\x1f\n\navatar_url\x18\x05\x20\x01(\tH\0R\tavatarUrl\
    \x12!\n\x0bavatar_data\x18\x06\x20\x01(\x0cH\0R\navatarData\x12\x1d\n\nc\
    ountry_id\x18\t\x20\x01(\tR\tcountryId\x12\x1d\n\ncollege_id\x18\n\x20\
    \x01(\tR\tcollegeId\x12\x19\n\x05email\x18\x0b\x20\x01(\tH\x02R\x05email\
    \x88\x01\x01B\x08\n\x06avatarB\x0f\n\r_phone_numberB\x08\n\x06_email\"\
    \x80\x01\n\x14ResetPasswordRequest\x12#\n\x0cphone_number\x18\x01\x20\
    \x01(\tH\0R\x0bphoneNumber\x12\x16\n\x05email\x18\x02\x20\x01(\tH\0R\x05\
    email\x12\x1a\n\x08password\x18\x04\x20\x01(\tR\x08passwordB\x0f\n\rrese\
    t_payload\"\xe6\x05\n\x07Account\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02\
    id\x12&\n\x0cphone_number\x18\x02\x20\x01(\tH\0R\x0bphoneNumber\x88\x01\
    \x01\x12\x1a\n\x08username\x18\x03\x20\x01(\tR\x08username\x12\x1f\n\x0b\
    language_id\x18\x04\x20\x01(\tR\nlanguageId\x129\n\ncreated_at\x18\x05\
    \x20\x01(\x0b2\x1a.google.protobuf.TimestampR\tcreatedAt\x129\n\nupdated\
    _at\x18\x06\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\tupdatedAt\x12\
    \"\n\navatar_url\x18\x07\x20\x01(\tH\x01R\tavatarUrl\x88\x01\x01\x12\x1d\
    \n\ncountry_id\x18\t\x20\x01(\tR\tcountryId\x12\x20\n\tdevice_id\x18\n\
    \x20\x01(\tH\x02R\x08deviceId\x88\x01\x01\x12&\n\x0cdevice_token\x18\x0b\
    \x20\x01(\tH\x03R\x0bdeviceToken\x88\x01\x01\x12$\n\x0bdevice_type\x18\
    \x0c\x20\x01(\tH\x04R\ndeviceType\x88\x01\x01\x12$\n\x0bis_verified\x18\
    \r\x20\x01(\x08H\x05R\nisVerified\x88\x01\x01\x123\n\tuser_type\x18\x0e\
    \x20\x01(\x0e2\x11.qreeket.UserTypeH\x06R\x08userType\x88\x01\x01\x12\
    \x1d\n\ncollege_id\x18\x0f\x20\x01(\tR\tcollegeId\x12\x19\n\x05email\x18\
    \x10\x20\x01(\tH\x07R\x05email\x88\x01\x01\x12\"\n\nis_visible\x18\x11\
    \x20\x01(\x08H\x08R\tisVisible\x88\x01\x01B\x0f\n\r_phone_numberB\r\n\
    \x0b_avatar_urlB\x0c\n\n_device_idB\x0f\n\r_device_tokenB\x0e\n\x0c_devi\
    ce_typeB\x0e\n\x0c_is_verifiedB\x0c\n\n_user_typeB\x08\n\x06_emailB\r\n\
    \x0b_is_visible\"Z\n\x10AccessTokenStore\x12!\n\x0caccess_token\x18\x01\
    \x20\x01(\tR\x0baccessToken\x12#\n\rrefresh_token\x18\x03\x20\x01(\tR\
    \x0crefreshToken\"\xdf\x01\n\x07Country\x12\x0e\n\x02id\x18\x01\x20\x01(\
    \tR\x02id\x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04name\x12\x12\n\x04cod\
    e\x18\x03\x20\x01(\tR\x04code\x12\x1b\n\tdial_code\x18\x04\x20\x01(\tR\
    \x08dialCode\x12\x1a\n\x08currency\x18\x05\x20\x01(\tR\x08currency\x12'\
    \n\x0fcurrency_symbol\x18\x06\x20\x01(\tR\x0ecurrencySymbol\x12\x19\n\
    \x08flag_url\x18\x07\x20\x01(\tR\x07flagUrl\x12\x1f\n\x0blanguage_id\x18\
    \x08\x20\x01(\tR\nlanguageId\"\xce\x01\n\x07College\x12\x0e\n\x02id\x18\
    \x01\x20\x01(\tR\x02id\x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04name\x12\
    \x18\n\x07address\x18\x03\x20\x01(\tR\x07address\x12\x19\n\x08logo_url\
    \x18\x04\x20\x01(\tR\x07logoUrl\x12\x18\n\x07website\x18\x05\x20\x01(\tR\
    \x07website\x12\x1d\n\ncountry_id\x18\x06\x20\x01(\tR\tcountryId\x12\"\n\
    \nbanner_url\x18\x07\x20\x01(\tH\0R\tbannerUrl\x88\x01\x01B\r\n\x0b_bann\
    er_url*%\n\x08UserType\x12\x0c\n\x08standard\x10\0\x12\x0b\n\x07premium\
    \x10\x012\xf7\r\n\x0bAuthService\x12<\n\x05login\x12\x15.qreeket.LoginRe\
    quest\x1a\x1c.google.protobuf.StringValue\x12B\n\x08register\x12\x18.qre\
    eket.RegisterRequest\x1a\x1c.google.protobuf.StringValue\x12M\n\x0ereset\
    _password\x12\x1d.qreeket.ResetPasswordRequest\x1a\x1c.google.protobuf.S\
    tringValue\x128\n\x06logout\x12\x16.google.protobuf.Empty\x1a\x16.google\
    .protobuf.Empty\x12G\n\x0fverify_password\x12\x1c.google.protobuf.String\
    Value\x1a\x16.google.protobuf.Empty\x12D\n\x12upgrade_to_premium\x12\x16\
    .google.protobuf.Empty\x1a\x16.google.protobuf.Empty\x12G\n\x15downgrade\
    _to_standard\x12\x16.google.protobuf.Empty\x1a\x16.google.protobuf.Empty\
    \x12S\n\x1brequest_public_access_token\x12\x16.google.protobuf.Empty\x1a\
    \x1c.google.protobuf.StringValue\x12U\n\x15validate_access_token\x12\x16\
    .google.protobuf.Empty\x1a$.qreeket.ValidateAccessTokenResponse\x127\n\
    \x0bget_account\x12\x16.google.protobuf.Empty\x1a\x10.qreeket.Account\
    \x12M\n\x1bget_account_by_phone_number\x12\x1c.google.protobuf.StringVal\
    ue\x1a\x10.qreeket.Account\x12C\n\x11get_account_by_id\x12\x1c.google.pr\
    otobuf.StringValue\x1a\x10.qreeket.Account\x124\n\x0eupdate_account\x12\
    \x10.qreeket.Account\x1a\x10.qreeket.Account\x12@\n\x0edelete_account\
    \x12\x16.google.protobuf.Empty\x1a\x16.google.protobuf.Empty\x12c\n\x14a\
    uthenticate_account\x12-.qreeket.AuthenticateWithSocialAccountRequest\
    \x1a\x1c.google.protobuf.StringValue\x12C\n\x0bcheck_email\x12\x1c.googl\
    e.protobuf.StringValue\x1a\x16.google.protobuf.Empty\x12J\n\x12check_pho\
    ne_number\x12\x1c.google.protobuf.StringValue\x1a\x16.google.protobuf.Em\
    pty\x12F\n\rget_countries\x12\x16.google.protobuf.Empty\x1a\x1d.qreeket.\
    GetCountriesResponse\x12C\n\x11get_country_by_id\x12\x1c.google.protobuf\
    .StringValue\x1a\x10.qreeket.Country\x121\n\x0badd_country\x12\x10.qreek\
    et.Country\x1a\x10.qreeket.Country\x12F\n\x0edelete_country\x12\x1c.goog\
    le.protobuf.StringValue\x1a\x16.google.protobuf.Empty\x12V\n\x18get_coll\
    eges_for_country\x12\x1c.google.protobuf.StringValue\x1a\x1c.qreeket.Get\
    CollegesResponse\x12C\n\x11get_college_by_id\x12\x1c.google.protobuf.Str\
    ingValue\x1a\x10.qreeket.College\x121\n\x0badd_college\x12\x10.qreeket.C\
    ollege\x1a\x10.qreeket.College\x12F\n\x0edelete_college\x12\x1c.google.p\
    rotobuf.StringValue\x1a\x16.google.protobuf.EmptyB!Z\x1fgithub.com/qcode\
    labsllc/qreeketJ\x8a/\n\x07\x12\x05\0\0\x9e\x01\x01\n\x08\n\x01\x0c\x12\
    \x03\0\0\x12\n\x08\n\x01\x02\x12\x03\x01\0\x10\n\x08\n\x01\x08\x12\x03\
    \x02\06\n\t\n\x02\x08\x0b\x12\x03\x02\06\n\t\n\x02\x03\0\x12\x03\x04\0)\
    \n\t\n\x02\x03\x01\x12\x03\x05\0%\n\t\n\x02\x03\x02\x12\x03\x06\0(\nm\n\
    \x02\x06\0\x12\x04\t\00\x01\x1aa\x20authentication\x20service\x20for\x20\
    user\x20login,\x20register,\x20reset\x20password,\x20refresh\x20token,\
    \x20logout\x20and\x20etc.\n\n\n\n\x03\x06\0\x01\x12\x03\t\x08\x13\n\x13\
    \n\x04\x06\0\x02\0\x12\x03\x0b\x02A\x1a\x06\x20auth\n\n\x0c\n\x05\x06\0\
    \x02\0\x01\x12\x03\x0b\x06\x0b\n\x0c\n\x05\x06\0\x02\0\x02\x12\x03\x0b\r\
    \x19\n\x0c\n\x05\x06\0\x02\0\x03\x12\x03\x0b$?\n\x0b\n\x04\x06\0\x02\x01\
    \x12\x03\x0c\x02G\n\x0c\n\x05\x06\0\x02\x01\x01\x12\x03\x0c\x06\x0e\n\
    \x0c\n\x05\x06\0\x02\x01\x02\x12\x03\x0c\x10\x1f\n\x0c\n\x05\x06\0\x02\
    \x01\x03\x12\x03\x0c*E\n\x0b\n\x04\x06\0\x02\x02\x12\x03\r\x02R\n\x0c\n\
    \x05\x06\0\x02\x02\x01\x12\x03\r\x06\x14\n\x0c\n\x05\x06\0\x02\x02\x02\
    \x12\x03\r\x16*\n\x0c\n\x05\x06\0\x02\x02\x03\x12\x03\r5P\n\x0b\n\x04\
    \x06\0\x02\x03\x12\x03\x0e\x02E\n\x0c\n\x05\x06\0\x02\x03\x01\x12\x03\
    \x0e\x06\x0c\n\x0c\n\x05\x06\0\x02\x03\x02\x12\x03\x0e\x0e#\n\x0c\n\x05\
    \x06\0\x02\x03\x03\x12\x03\x0e.C\n\x0b\n\x04\x06\0\x02\x04\x12\x03\x0f\
    \x02T\n\x0c\n\x05\x06\0\x02\x04\x01\x12\x03\x0f\x06\x15\n\x0c\n\x05\x06\
    \0\x02\x04\x02\x12\x03\x0f\x172\n\x0c\n\x05\x06\0\x02\x04\x03\x12\x03\
    \x0f=R\n&\n\x04\x06\0\x02\x05\x12\x03\x12\x02Q\x1a\x19\x20premium\x20acc\
    ount\x20upgrade\n\n\x0c\n\x05\x06\0\x02\x05\x01\x12\x03\x12\x06\x18\n\
    \x0c\n\x05\x06\0\x02\x05\x02\x12\x03\x12\x1a/\n\x0c\n\x05\x06\0\x02\x05\
    \x03\x12\x03\x12:O\n\x0b\n\x04\x06\0\x02\x06\x12\x03\x13\x02T\n\x0c\n\
    \x05\x06\0\x02\x06\x01\x12\x03\x13\x06\x1b\n\x0c\n\x05\x06\0\x02\x06\x02\
    \x12\x03\x13\x1d2\n\x0c\n\x05\x06\0\x02\x06\x03\x12\x03\x13=R\nD\n\x04\
    \x06\0\x02\x07\x12\x03\x16\x02`\x1a7\x20request\x20public\x20access\x20t\
    oken\x20for\x20unauthenticated\x20calls\n\n\x0c\n\x05\x06\0\x02\x07\x01\
    \x12\x03\x16\x06!\n\x0c\n\x05\x06\0\x02\x07\x02\x12\x03\x16#8\n\x0c\n\
    \x05\x06\0\x02\x07\x03\x12\x03\x16C^\nc\n\x04\x06\0\x02\x08\x12\x03\x19\
    \x02Z\x1aV\x20validate\x20access\x20token\x20from\x20microservices\x20fo\
    r\x20authorization\x20(only\x20for\x20internal\x20calls)\n\n\x0c\n\x05\
    \x06\0\x02\x08\x01\x12\x03\x19\x06\x1b\n\x0c\n\x05\x06\0\x02\x08\x02\x12\
    \x03\x19\x1d2\n\x0c\n\x05\x06\0\x02\x08\x03\x12\x03\x19=X\n\x16\n\x04\
    \x06\0\x02\t\x12\x03\x1c\x02<\x1a\t\x20account\n\n\x0c\n\x05\x06\0\x02\t\
    \x01\x12\x03\x1c\x06\x11\n\x0c\n\x05\x06\0\x02\t\x02\x12\x03\x1c\x13(\n\
    \x0c\n\x05\x06\0\x02\t\x03\x12\x03\x1c3:\n\x0b\n\x04\x06\0\x02\n\x12\x03\
    \x1d\x02R\n\x0c\n\x05\x06\0\x02\n\x01\x12\x03\x1d\x06!\n\x0c\n\x05\x06\0\
    \x02\n\x02\x12\x03\x1d#>\n\x0c\n\x05\x06\0\x02\n\x03\x12\x03\x1dIP\n\x0b\
    \n\x04\x06\0\x02\x0b\x12\x03\x1e\x02H\n\x0c\n\x05\x06\0\x02\x0b\x01\x12\
    \x03\x1e\x06\x17\n\x0c\n\x05\x06\0\x02\x0b\x02\x12\x03\x1e\x194\n\x0c\n\
    \x05\x06\0\x02\x0b\x03\x12\x03\x1e?F\n\x0b\n\x04\x06\0\x02\x0c\x12\x03\
    \x1f\x021\n\x0c\n\x05\x06\0\x02\x0c\x01\x12\x03\x1f\x06\x14\n\x0c\n\x05\
    \x06\0\x02\x0c\x02\x12\x03\x1f\x16\x1d\n\x0c\n\x05\x06\0\x02\x0c\x03\x12\
    \x03\x1f(/\n\x0b\n\x04\x06\0\x02\r\x12\x03\x20\x02M\n\x0c\n\x05\x06\0\
    \x02\r\x01\x12\x03\x20\x06\x14\n\x0c\n\x05\x06\0\x02\r\x02\x12\x03\x20\
    \x16+\n\x0c\n\x05\x06\0\x02\r\x03\x12\x03\x206K\n\x0b\n\x04\x06\0\x02\
    \x0e\x12\x03!\x02h\n\x0c\n\x05\x06\0\x02\x0e\x01\x12\x03!\x06\x1a\n\x0c\
    \n\x05\x06\0\x02\x0e\x02\x12\x03!\x1c@\n\x0c\n\x05\x06\0\x02\x0e\x03\x12\
    \x03!Kf\n\x0b\n\x04\x06\0\x02\x0f\x12\x03\"\x02P\n\x0c\n\x05\x06\0\x02\
    \x0f\x01\x12\x03\"\x06\x11\n\x0c\n\x05\x06\0\x02\x0f\x02\x12\x03\"\x13.\
    \n\x0c\n\x05\x06\0\x02\x0f\x03\x12\x03\"9N\n\x0b\n\x04\x06\0\x02\x10\x12\
    \x03#\x02W\n\x0c\n\x05\x06\0\x02\x10\x01\x12\x03#\x06\x18\n\x0c\n\x05\
    \x06\0\x02\x10\x02\x12\x03#\x1a5\n\x0c\n\x05\x06\0\x02\x10\x03\x12\x03#@\
    U\n\x16\n\x04\x06\0\x02\x11\x12\x03&\x02K\x1a\t\x20country\n\n\x0c\n\x05\
    \x06\0\x02\x11\x01\x12\x03&\x06\x13\n\x0c\n\x05\x06\0\x02\x11\x02\x12\
    \x03&\x15*\n\x0c\n\x05\x06\0\x02\x11\x03\x12\x03&5I\n\x0b\n\x04\x06\0\
    \x02\x12\x12\x03'\x02H\n\x0c\n\x05\x06\0\x02\x12\x01\x12\x03'\x06\x17\n\
    \x0c\n\x05\x06\0\x02\x12\x02\x12\x03'\x194\n\x0c\n\x05\x06\0\x02\x12\x03\
    \x12\x03'?F\n\x0b\n\x04\x06\0\x02\x13\x12\x03(\x02.\n\x0c\n\x05\x06\0\
    \x02\x13\x01\x12\x03(\x06\x11\n\x0c\n\x05\x06\0\x02\x13\x02\x12\x03(\x13\
    \x1a\n\x0c\n\x05\x06\0\x02\x13\x03\x12\x03(%,\n\x0b\n\x04\x06\0\x02\x14\
    \x12\x03)\x02S\n\x0c\n\x05\x06\0\x02\x14\x01\x12\x03)\x06\x14\n\x0c\n\
    \x05\x06\0\x02\x14\x02\x12\x03)\x161\n\x0c\n\x05\x06\0\x02\x14\x03\x12\
    \x03)<Q\n\x16\n\x04\x06\0\x02\x15\x12\x03,\x02[\x1a\t\x20college\n\n\x0c\
    \n\x05\x06\0\x02\x15\x01\x12\x03,\x06\x1e\n\x0c\n\x05\x06\0\x02\x15\x02\
    \x12\x03,\x20;\n\x0c\n\x05\x06\0\x02\x15\x03\x12\x03,FY\n\x0b\n\x04\x06\
    \0\x02\x16\x12\x03-\x02H\n\x0c\n\x05\x06\0\x02\x16\x01\x12\x03-\x06\x17\
    \n\x0c\n\x05\x06\0\x02\x16\x02\x12\x03-\x194\n\x0c\n\x05\x06\0\x02\x16\
    \x03\x12\x03-?F\n\x0b\n\x04\x06\0\x02\x17\x12\x03.\x02.\n\x0c\n\x05\x06\
    \0\x02\x17\x01\x12\x03.\x06\x11\n\x0c\n\x05\x06\0\x02\x17\x02\x12\x03.\
    \x13\x1a\n\x0c\n\x05\x06\0\x02\x17\x03\x12\x03.%,\n\x0b\n\x04\x06\0\x02\
    \x18\x12\x03/\x02S\n\x0c\n\x05\x06\0\x02\x18\x01\x12\x03/\x06\x14\n\x0c\
    \n\x05\x06\0\x02\x18\x02\x12\x03/\x161\n\x0c\n\x05\x06\0\x02\x18\x03\x12\
    \x03/<Q\n\n\n\x02\x04\0\x12\x042\0<\x01\n\n\n\x03\x04\0\x01\x12\x032\x08\
    ,\n\x0b\n\x04\x04\0\x02\0\x12\x033\x02\x1a\n\x0c\n\x05\x04\0\x02\0\x05\
    \x12\x033\x02\x08\n\x0c\n\x05\x04\0\x02\0\x01\x12\x033\t\x15\n\x0c\n\x05\
    \x04\0\x02\0\x03\x12\x033\x18\x19\n\x0b\n\x04\x04\0\x02\x01\x12\x034\x02\
    \x16\n\x0c\n\x05\x04\0\x02\x01\x05\x12\x034\x02\x08\n\x0c\n\x05\x04\0\
    \x02\x01\x01\x12\x034\t\x11\n\x0c\n\x05\x04\0\x02\x01\x03\x12\x034\x14\
    \x15\n\x0c\n\x04\x04\0\x08\0\x12\x045\x028\x03\n\x0c\n\x05\x04\0\x08\0\
    \x01\x12\x035\x08\x13\n\x0b\n\x04\x04\0\x02\x02\x12\x036\x04\x1a\n\x0c\n\
    \x05\x04\0\x02\x02\x05\x12\x036\x04\n\n\x0c\n\x05\x04\0\x02\x02\x01\x12\
    \x036\x0b\x15\n\x0c\n\x05\x04\0\x02\x02\x03\x12\x036\x18\x19\n\x0b\n\x04\
    \x04\0\x02\x03\x12\x037\x04\x1a\n\x0c\n\x05\x04\0\x02\x03\x05\x12\x037\
    \x04\t\n\x0c\n\x05\x04\0\x02\x03\x01\x12\x037\n\x15\n\x0c\n\x05\x04\0\
    \x02\x03\x03\x12\x037\x18\x19\n\x0b\n\x04\x04\0\x02\x04\x12\x039\x02\x18\
    \n\x0c\n\x05\x04\0\x02\x04\x05\x12\x039\x02\x08\n\x0c\n\x05\x04\0\x02\
    \x04\x01\x12\x039\t\x13\n\x0c\n\x05\x04\0\x02\x04\x03\x12\x039\x16\x17\n\
    \x0b\n\x04\x04\0\x02\x05\x12\x03:\x02\x18\n\x0c\n\x05\x04\0\x02\x05\x05\
    \x12\x03:\x02\x08\n\x0c\n\x05\x04\0\x02\x05\x01\x12\x03:\t\x13\n\x0c\n\
    \x05\x04\0\x02\x05\x03\x12\x03:\x16\x17\n\x0b\n\x04\x04\0\x02\x06\x12\
    \x03;\x02\x13\n\x0c\n\x05\x04\0\x02\x06\x05\x12\x03;\x02\x08\n\x0c\n\x05\
    \x04\0\x02\x06\x01\x12\x03;\t\x0e\n\x0c\n\x05\x04\0\x02\x06\x03\x12\x03;\
    \x11\x12\n\n\n\x02\x04\x01\x12\x04>\0@\x01\n\n\n\x03\x04\x01\x01\x12\x03\
    >\x08\x1b\n\x0b\n\x04\x04\x01\x02\0\x12\x03?\x02\x20\n\x0c\n\x05\x04\x01\
    \x02\0\x04\x12\x03?\x02\n\n\x0c\n\x05\x04\x01\x02\0\x06\x12\x03?\x0b\x12\
    \n\x0c\n\x05\x04\x01\x02\0\x01\x12\x03?\x13\x1b\n\x0c\n\x05\x04\x01\x02\
    \0\x03\x12\x03?\x1e\x1f\n\n\n\x02\x04\x02\x12\x04B\0D\x01\n\n\n\x03\x04\
    \x02\x01\x12\x03B\x08\x1c\n\x0b\n\x04\x04\x02\x02\0\x12\x03C\x02!\n\x0c\
    \n\x05\x04\x02\x02\0\x04\x12\x03C\x02\n\n\x0c\n\x05\x04\x02\x02\0\x06\
    \x12\x03C\x0b\x12\n\x0c\n\x05\x04\x02\x02\0\x01\x12\x03C\x13\x1c\n\x0c\n\
    \x05\x04\x02\x02\0\x03\x12\x03C\x1f\x20\n4\n\x02\x04\x03\x12\x04G\0K\x01\
    \x1a(\x20validate\x20access\x20token\x20response\x20message\n\n\n\n\x03\
    \x04\x03\x01\x12\x03G\x08#\n\x0b\n\x04\x04\x03\x02\0\x12\x03H\x02!\n\x0c\
    \n\x05\x04\x03\x02\0\x04\x12\x03H\x02\n\n\x0c\n\x05\x04\x03\x02\0\x05\
    \x12\x03H\x0b\x11\n\x0c\n\x05\x04\x03\x02\0\x01\x12\x03H\x12\x1c\n\x0c\n\
    \x05\x04\x03\x02\0\x03\x12\x03H\x1f\x20\n\x0b\n\x04\x04\x03\x02\x01\x12\
    \x03I\x02#\n\x0c\n\x05\x04\x03\x02\x01\x04\x12\x03I\x02\n\n\x0c\n\x05\
    \x04\x03\x02\x01\x05\x12\x03I\x0b\x11\n\x0c\n\x05\x04\x03\x02\x01\x01\
    \x12\x03I\x12\x1e\n\x0c\n\x05\x04\x03\x02\x01\x03\x12\x03I!\"\n\x0b\n\
    \x04\x04\x03\x02\x02\x12\x03J\x02\x1f\n\x0c\n\x05\x04\x03\x02\x02\x04\
    \x12\x03J\x02\n\n\x0c\n\x05\x04\x03\x02\x02\x05\x12\x03J\x0b\x11\n\x0c\n\
    \x05\x04\x03\x02\x02\x01\x12\x03J\x12\x1a\n\x0c\n\x05\x04\x03\x02\x02\
    \x03\x12\x03J\x1d\x1e\n#\n\x02\x04\x04\x12\x04N\0U\x01\x1a\x17\x20login\
    \x20request\x20message\n\n\n\n\x03\x04\x04\x01\x12\x03N\x08\x14\n\x0c\n\
    \x04\x04\x04\x08\0\x12\x04O\x02R\x03\n\x0c\n\x05\x04\x04\x08\0\x01\x12\
    \x03O\x08\x0f\n\x0b\n\x04\x04\x04\x02\0\x12\x03P\x04\x1c\n\x0c\n\x05\x04\
    \x04\x02\0\x05\x12\x03P\x04\n\n\x0c\n\x05\x04\x04\x02\0\x01\x12\x03P\x0b\
    \x17\n\x0c\n\x05\x04\x04\x02\0\x03\x12\x03P\x1a\x1b\n\x0b\n\x04\x04\x04\
    \x02\x01\x12\x03Q\x04\x15\n\x0c\n\x05\x04\x04\x02\x01\x05\x12\x03Q\x04\n\
    \n\x0c\n\x05\x04\x04\x02\x01\x01\x12\x03Q\x0b\x10\n\x0c\n\x05\x04\x04\
    \x02\x01\x03\x12\x03Q\x13\x14\n\x0b\n\x04\x04\x04\x02\x02\x12\x03S\x02\
    \x16\n\x0c\n\x05\x04\x04\x02\x02\x05\x12\x03S\x02\x08\n\x0c\n\x05\x04\
    \x04\x02\x02\x01\x12\x03S\t\x11\n\x0c\n\x05\x04\x04\x02\x02\x03\x12\x03S\
    \x14\x15\n\x0b\n\x04\x04\x04\x02\x03\x12\x03T\x02\x18\n\x0c\n\x05\x04\
    \x04\x02\x03\x05\x12\x03T\x02\x08\n\x0c\n\x05\x04\x04\x02\x03\x01\x12\
    \x03T\t\x13\n\x0c\n\x05\x04\x04\x02\x03\x03\x12\x03T\x16\x17\nD\n\x02\
    \x04\x05\x12\x04Y\0d\x0128\x20auth\x20response\x20message\x20contains\
    \x20token\x20and\x20refresh\x20token\n\n\n\n\x03\x04\x05\x01\x12\x03Y\
    \x08\x17\n\x0b\n\x04\x04\x05\x02\0\x12\x03Z\x02#\n\x0c\n\x05\x04\x05\x02\
    \0\x04\x12\x03Z\x02\n\n\x0c\n\x05\x04\x05\x02\0\x05\x12\x03Z\x0b\x11\n\
    \x0c\n\x05\x04\x05\x02\0\x01\x12\x03Z\x12\x1e\n\x0c\n\x05\x04\x05\x02\0\
    \x03\x12\x03Z!\"\n\x0b\n\x04\x04\x05\x02\x01\x12\x03[\x02\x16\n\x0c\n\
    \x05\x04\x05\x02\x01\x05\x12\x03[\x02\x08\n\x0c\n\x05\x04\x05\x02\x01\
    \x01\x12\x03[\t\x11\n\x0c\n\x05\x04\x05\x02\x01\x03\x12\x03[\x14\x15\n\
    \x0b\n\x04\x04\x05\x02\x02\x12\x03\\\x02\x16\n\x0c\n\x05\x04\x05\x02\x02\
    \x05\x12\x03\\\x02\x08\n\x0c\n\x05\x04\x05\x02\x02\x01\x12\x03\\\t\x11\n\
    \x0c\n\x05\x04\x05\x02\x02\x03\x12\x03\\\x14\x15\n\x0c\n\x04\x04\x05\x08\
    \0\x12\x04]\x02`\x03\n\x0c\n\x05\x04\x05\x08\0\x01\x12\x03]\x08\x0e\n\
    \x0b\n\x04\x04\x05\x02\x03\x12\x03^\x04\x1a\n\x0c\n\x05\x04\x05\x02\x03\
    \x05\x12\x03^\x04\n\n\x0c\n\x05\x04\x05\x02\x03\x01\x12\x03^\x0b\x15\n\
    \x0c\n\x05\x04\x05\x02\x03\x03\x12\x03^\x18\x19\n\x0b\n\x04\x04\x05\x02\
    \x04\x12\x03_\x04\x1a\n\x0c\n\x05\x04\x05\x02\x04\x05\x12\x03_\x04\t\n\
    \x0c\n\x05\x04\x05\x02\x04\x01\x12\x03_\n\x15\n\x0c\n\x05\x04\x05\x02\
    \x04\x03\x12\x03_\x18\x19\n\x0b\n\x04\x04\x05\x02\x05\x12\x03a\x02\x18\n\
    \x0c\n\x05\x04\x05\x02\x05\x05\x12\x03a\x02\x08\n\x0c\n\x05\x04\x05\x02\
    \x05\x01\x12\x03a\t\x13\n\x0c\n\x05\x04\x05\x02\x05\x03\x12\x03a\x16\x17\
    \n\x0b\n\x04\x04\x05\x02\x06\x12\x03b\x02\x19\n\x0c\n\x05\x04\x05\x02\
    \x06\x05\x12\x03b\x02\x08\n\x0c\n\x05\x04\x05\x02\x06\x01\x12\x03b\t\x13\
    \n\x0c\n\x05\x04\x05\x02\x06\x03\x12\x03b\x16\x18\n\x0b\n\x04\x04\x05\
    \x02\x07\x12\x03c\x02\x1d\n\x0c\n\x05\x04\x05\x02\x07\x04\x12\x03c\x02\n\
    \n\x0c\n\x05\x04\x05\x02\x07\x05\x12\x03c\x0b\x11\n\x0c\n\x05\x04\x05\
    \x02\x07\x01\x12\x03c\x12\x17\n\x0c\n\x05\x04\x05\x02\x07\x03\x12\x03c\
    \x1a\x1c\n\n\n\x02\x04\x06\x12\x04f\0l\x01\n\n\n\x03\x04\x06\x01\x12\x03\
    f\x08\x1c\n\x0c\n\x04\x04\x06\x08\0\x12\x04g\x02j\x03\n\x0c\n\x05\x04\
    \x06\x08\0\x01\x12\x03g\x08\x15\n\x0b\n\x04\x04\x06\x02\0\x12\x03h\x04\
    \x1c\n\x0c\n\x05\x04\x06\x02\0\x05\x12\x03h\x04\n\n\x0c\n\x05\x04\x06\
    \x02\0\x01\x12\x03h\x0b\x17\n\x0c\n\x05\x04\x06\x02\0\x03\x12\x03h\x1a\
    \x1b\n\x0b\n\x04\x04\x06\x02\x01\x12\x03i\x04\x15\n\x0c\n\x05\x04\x06\
    \x02\x01\x05\x12\x03i\x04\n\n\x0c\n\x05\x04\x06\x02\x01\x01\x12\x03i\x0b\
    \x10\n\x0c\n\x05\x04\x06\x02\x01\x03\x12\x03i\x13\x14\n\x0b\n\x04\x04\
    \x06\x02\x02\x12\x03k\x02\x16\n\x0c\n\x05\x04\x06\x02\x02\x05\x12\x03k\
    \x02\x08\n\x0c\n\x05\x04\x06\x02\x02\x01\x12\x03k\t\x11\n\x0c\n\x05\x04\
    \x06\x02\x02\x03\x12\x03k\x14\x15\n\n\n\x02\x04\x07\x12\x04n\0\x7f\x01\n\
    \n\n\x03\x04\x07\x01\x12\x03n\x08\x0f\n\x0b\n\x04\x04\x07\x02\0\x12\x03o\
    \x02\x10\n\x0c\n\x05\x04\x07\x02\0\x05\x12\x03o\x02\x08\n\x0c\n\x05\x04\
    \x07\x02\0\x01\x12\x03o\t\x0b\n\x0c\n\x05\x04\x07\x02\0\x03\x12\x03o\x0e\
    \x0f\n\x0b\n\x04\x04\x07\x02\x01\x12\x03p\x02#\n\x0c\n\x05\x04\x07\x02\
    \x01\x04\x12\x03p\x02\n\n\x0c\n\x05\x04\x07\x02\x01\x05\x12\x03p\x0b\x11\
    \n\x0c\n\x05\x04\x07\x02\x01\x01\x12\x03p\x12\x1e\n\x0c\n\x05\x04\x07\
    \x02\x01\x03\x12\x03p!\"\n\x0b\n\x04\x04\x07\x02\x02\x12\x03q\x02\x16\n\
    \x0c\n\x05\x04\x07\x02\x02\x05\x12\x03q\x02\x08\n\x0c\n\x05\x04\x07\x02\
    \x02\x01\x12\x03q\t\x11\n\x0c\n\x05\x04\x07\x02\x02\x03\x12\x03q\x14\x15\
    \n\x0b\n\x04\x04\x07\x02\x03\x12\x03r\x02\x19\n\x0c\n\x05\x04\x07\x02\
    \x03\x05\x12\x03r\x02\x08\n\x0c\n\x05\x04\x07\x02\x03\x01\x12\x03r\t\x14\
    \n\x0c\n\x05\x04\x07\x02\x03\x03\x12\x03r\x17\x18\n\x0b\n\x04\x04\x07\
    \x02\x04\x12\x03s\x02+\n\x0c\n\x05\x04\x07\x02\x04\x06\x12\x03s\x02\x1b\
    \n\x0c\n\x05\x04\x07\x02\x04\x01\x12\x03s\x1c&\n\x0c\n\x05\x04\x07\x02\
    \x04\x03\x12\x03s)*\n\x0b\n\x04\x04\x07\x02\x05\x12\x03t\x02+\n\x0c\n\
    \x05\x04\x07\x02\x05\x06\x12\x03t\x02\x1b\n\x0c\n\x05\x04\x07\x02\x05\
    \x01\x12\x03t\x1c&\n\x0c\n\x05\x04\x07\x02\x05\x03\x12\x03t)*\n\x0b\n\
    \x04\x04\x07\x02\x06\x12\x03u\x02!\n\x0c\n\x05\x04\x07\x02\x06\x04\x12\
    \x03u\x02\n\n\x0c\n\x05\x04\x07\x02\x06\x05\x12\x03u\x0b\x11\n\x0c\n\x05\
    \x04\x07\x02\x06\x01\x12\x03u\x12\x1c\n\x0c\n\x05\x04\x07\x02\x06\x03\
    \x12\x03u\x1f\x20\n\x0b\n\x04\x04\x07\x02\x07\x12\x03v\x02\x18\n\x0c\n\
    \x05\x04\x07\x02\x07\x05\x12\x03v\x02\x08\n\x0c\n\x05\x04\x07\x02\x07\
    \x01\x12\x03v\t\x13\n\x0c\n\x05\x04\x07\x02\x07\x03\x12\x03v\x16\x17\n\
    \x0b\n\x04\x04\x07\x02\x08\x12\x03w\x02!\n\x0c\n\x05\x04\x07\x02\x08\x04\
    \x12\x03w\x02\n\n\x0c\n\x05\x04\x07\x02\x08\x05\x12\x03w\x0b\x11\n\x0c\n\
    \x05\x04\x07\x02\x08\x01\x12\x03w\x12\x1b\n\x0c\n\x05\x04\x07\x02\x08\
    \x03\x12\x03w\x1e\x20\n\x0b\n\x04\x04\x07\x02\t\x12\x03x\x02$\n\x0c\n\
    \x05\x04\x07\x02\t\x04\x12\x03x\x02\n\n\x0c\n\x05\x04\x07\x02\t\x05\x12\
    \x03x\x0b\x11\n\x0c\n\x05\x04\x07\x02\t\x01\x12\x03x\x12\x1e\n\x0c\n\x05\
    \x04\x07\x02\t\x03\x12\x03x!#\n\x0b\n\x04\x04\x07\x02\n\x12\x03y\x02#\n\
    \x0c\n\x05\x04\x07\x02\n\x04\x12\x03y\x02\n\n\x0c\n\x05\x04\x07\x02\n\
    \x05\x12\x03y\x0b\x11\n\x0c\n\x05\x04\x07\x02\n\x01\x12\x03y\x12\x1d\n\
    \x0c\n\x05\x04\x07\x02\n\x03\x12\x03y\x20\"\n\x0b\n\x04\x04\x07\x02\x0b\
    \x12\x03z\x02!\n\x0c\n\x05\x04\x07\x02\x0b\x04\x12\x03z\x02\n\n\x0c\n\
    \x05\x04\x07\x02\x0b\x05\x12\x03z\x0b\x0f\n\x0c\n\x05\x04\x07\x02\x0b\
    \x01\x12\x03z\x10\x1b\n\x0c\n\x05\x04\x07\x02\x0b\x03\x12\x03z\x1e\x20\n\
    \x0b\n\x04\x04\x07\x02\x0c\x12\x03{\x02#\n\x0c\n\x05\x04\x07\x02\x0c\x04\
    \x12\x03{\x02\n\n\x0c\n\x05\x04\x07\x02\x0c\x06\x12\x03{\x0b\x13\n\x0c\n\
    \x05\x04\x07\x02\x0c\x01\x12\x03{\x14\x1d\n\x0c\n\x05\x04\x07\x02\x0c\
    \x03\x12\x03{\x20\"\n\x0b\n\x04\x04\x07\x02\r\x12\x03|\x02\x19\n\x0c\n\
    \x05\x04\x07\x02\r\x05\x12\x03|\x02\x08\n\x0c\n\x05\x04\x07\x02\r\x01\
    \x12\x03|\t\x13\n\x0c\n\x05\x04\x07\x02\r\x03\x12\x03|\x16\x18\n\x0b\n\
    \x04\x04\x07\x02\x0e\x12\x03}\x02\x1d\n\x0c\n\x05\x04\x07\x02\x0e\x04\
    \x12\x03}\x02\n\n\x0c\n\x05\x04\x07\x02\x0e\x05\x12\x03}\x0b\x11\n\x0c\n\
    \x05\x04\x07\x02\x0e\x01\x12\x03}\x12\x17\n\x0c\n\x05\x04\x07\x02\x0e\
    \x03\x12\x03}\x1a\x1c\n\x0b\n\x04\x04\x07\x02\x0f\x12\x03~\x02\x20\n\x0c\
    \n\x05\x04\x07\x02\x0f\x04\x12\x03~\x02\n\n\x0c\n\x05\x04\x07\x02\x0f\
    \x05\x12\x03~\x0b\x0f\n\x0c\n\x05\x04\x07\x02\x0f\x01\x12\x03~\x10\x1a\n\
    \x0c\n\x05\x04\x07\x02\x0f\x03\x12\x03~\x1d\x1f\n\x0c\n\x02\x04\x08\x12\
    \x06\x81\x01\0\x84\x01\x01\n\x0b\n\x03\x04\x08\x01\x12\x04\x81\x01\x08\
    \x18\n\x0c\n\x04\x04\x08\x02\0\x12\x04\x82\x01\x02\x1a\n\r\n\x05\x04\x08\
    \x02\0\x05\x12\x04\x82\x01\x02\x08\n\r\n\x05\x04\x08\x02\0\x01\x12\x04\
    \x82\x01\t\x15\n\r\n\x05\x04\x08\x02\0\x03\x12\x04\x82\x01\x18\x19\n\x0c\
    \n\x04\x04\x08\x02\x01\x12\x04\x83\x01\x02\x1b\n\r\n\x05\x04\x08\x02\x01\
    \x05\x12\x04\x83\x01\x02\x08\n\r\n\x05\x04\x08\x02\x01\x01\x12\x04\x83\
    \x01\t\x16\n\r\n\x05\x04\x08\x02\x01\x03\x12\x04\x83\x01\x19\x1a\n\x0c\n\
    \x02\x04\t\x12\x06\x86\x01\0\x8f\x01\x01\n\x0b\n\x03\x04\t\x01\x12\x04\
    \x86\x01\x08\x0f\n\x0c\n\x04\x04\t\x02\0\x12\x04\x87\x01\x02\x10\n\r\n\
    \x05\x04\t\x02\0\x05\x12\x04\x87\x01\x02\x08\n\r\n\x05\x04\t\x02\0\x01\
    \x12\x04\x87\x01\t\x0b\n\r\n\x05\x04\t\x02\0\x03\x12\x04\x87\x01\x0e\x0f\
    \n\x0c\n\x04\x04\t\x02\x01\x12\x04\x88\x01\x02\x12\n\r\n\x05\x04\t\x02\
    \x01\x05\x12\x04\x88\x01\x02\x08\n\r\n\x05\x04\t\x02\x01\x01\x12\x04\x88\
    \x01\t\r\n\r\n\x05\x04\t\x02\x01\x03\x12\x04\x88\x01\x10\x11\n\x0c\n\x04\
    \x04\t\x02\x02\x12\x04\x89\x01\x02\x12\n\r\n\x05\x04\t\x02\x02\x05\x12\
    \x04\x89\x01\x02\x08\n\r\n\x05\x04\t\x02\x02\x01\x12\x04\x89\x01\t\r\n\r\
    \n\x05\x04\t\x02\x02\x03\x12\x04\x89\x01\x10\x11\n\x0c\n\x04\x04\t\x02\
    \x03\x12\x04\x8a\x01\x02\x17\n\r\n\x05\x04\t\x02\x03\x05\x12\x04\x8a\x01\
    \x02\x08\n\r\n\x05\x04\t\x02\x03\x01\x12\x04\x8a\x01\t\x12\n\r\n\x05\x04\
    \t\x02\x03\x03\x12\x04\x8a\x01\x15\x16\n\x0c\n\x04\x04\t\x02\x04\x12\x04\
    \x8b\x01\x02\x16\n\r\n\x05\x04\t\x02\x04\x05\x12\x04\x8b\x01\x02\x08\n\r\
    \n\x05\x04\t\x02\x04\x01\x12\x04\x8b\x01\t\x11\n\r\n\x05\x04\t\x02\x04\
    \x03\x12\x04\x8b\x01\x14\x15\n\x0c\n\x04\x04\t\x02\x05\x12\x04\x8c\x01\
    \x02\x1d\n\r\n\x05\x04\t\x02\x05\x05\x12\x04\x8c\x01\x02\x08\n\r\n\x05\
    \x04\t\x02\x05\x01\x12\x04\x8c\x01\t\x18\n\r\n\x05\x04\t\x02\x05\x03\x12\
    \x04\x8c\x01\x1b\x1c\n\x0c\n\x04\x04\t\x02\x06\x12\x04\x8d\x01\x02\x16\n\
    \r\n\x05\x04\t\x02\x06\x05\x12\x04\x8d\x01\x02\x08\n\r\n\x05\x04\t\x02\
    \x06\x01\x12\x04\x8d\x01\t\x11\n\r\n\x05\x04\t\x02\x06\x03\x12\x04\x8d\
    \x01\x14\x15\n\x0c\n\x04\x04\t\x02\x07\x12\x04\x8e\x01\x02\x19\n\r\n\x05\
    \x04\t\x02\x07\x05\x12\x04\x8e\x01\x02\x08\n\r\n\x05\x04\t\x02\x07\x01\
    \x12\x04\x8e\x01\t\x14\n\r\n\x05\x04\t\x02\x07\x03\x12\x04\x8e\x01\x17\
    \x18\n\x0c\n\x02\x05\0\x12\x06\x91\x01\0\x94\x01\x01\n\x0b\n\x03\x05\0\
    \x01\x12\x04\x91\x01\x05\r\n\x0c\n\x04\x05\0\x02\0\x12\x04\x92\x01\x02\
    \x0f\n\r\n\x05\x05\0\x02\0\x01\x12\x04\x92\x01\x02\n\n\r\n\x05\x05\0\x02\
    \0\x02\x12\x04\x92\x01\r\x0e\n\x0c\n\x04\x05\0\x02\x01\x12\x04\x93\x01\
    \x02\x0e\n\r\n\x05\x05\0\x02\x01\x01\x12\x04\x93\x01\x02\t\n\r\n\x05\x05\
    \0\x02\x01\x02\x12\x04\x93\x01\x0c\r\n\x0c\n\x02\x04\n\x12\x06\x96\x01\0\
    \x9e\x01\x01\n\x0b\n\x03\x04\n\x01\x12\x04\x96\x01\x08\x0f\n\x0c\n\x04\
    \x04\n\x02\0\x12\x04\x97\x01\x02\x10\n\r\n\x05\x04\n\x02\0\x05\x12\x04\
    \x97\x01\x02\x08\n\r\n\x05\x04\n\x02\0\x01\x12\x04\x97\x01\t\x0b\n\r\n\
    \x05\x04\n\x02\0\x03\x12\x04\x97\x01\x0e\x0f\n\x0c\n\x04\x04\n\x02\x01\
    \x12\x04\x98\x01\x02\x12\n\r\n\x05\x04\n\x02\x01\x05\x12\x04\x98\x01\x02\
    \x08\n\r\n\x05\x04\n\x02\x01\x01\x12\x04\x98\x01\t\r\n\r\n\x05\x04\n\x02\
    \x01\x03\x12\x04\x98\x01\x10\x11\n\x0c\n\x04\x04\n\x02\x02\x12\x04\x99\
    \x01\x02\x15\n\r\n\x05\x04\n\x02\x02\x05\x12\x04\x99\x01\x02\x08\n\r\n\
    \x05\x04\n\x02\x02\x01\x12\x04\x99\x01\t\x10\n\r\n\x05\x04\n\x02\x02\x03\
    \x12\x04\x99\x01\x13\x14\n\x0c\n\x04\x04\n\x02\x03\x12\x04\x9a\x01\x02\
    \x16\n\r\n\x05\x04\n\x02\x03\x05\x12\x04\x9a\x01\x02\x08\n\r\n\x05\x04\n\
    \x02\x03\x01\x12\x04\x9a\x01\t\x11\n\r\n\x05\x04\n\x02\x03\x03\x12\x04\
    \x9a\x01\x14\x15\n\x0c\n\x04\x04\n\x02\x04\x12\x04\x9b\x01\x02\x15\n\r\n\
    \x05\x04\n\x02\x04\x05\x12\x04\x9b\x01\x02\x08\n\r\n\x05\x04\n\x02\x04\
    \x01\x12\x04\x9b\x01\t\x10\n\r\n\x05\x04\n\x02\x04\x03\x12\x04\x9b\x01\
    \x13\x14\n\x0c\n\x04\x04\n\x02\x05\x12\x04\x9c\x01\x02\x18\n\r\n\x05\x04\
    \n\x02\x05\x05\x12\x04\x9c\x01\x02\x08\n\r\n\x05\x04\n\x02\x05\x01\x12\
    \x04\x9c\x01\t\x13\n\r\n\x05\x04\n\x02\x05\x03\x12\x04\x9c\x01\x16\x17\n\
    \x0c\n\x04\x04\n\x02\x06\x12\x04\x9d\x01\x02!\n\r\n\x05\x04\n\x02\x06\
    \x04\x12\x04\x9d\x01\x02\n\n\r\n\x05\x04\n\x02\x06\x05\x12\x04\x9d\x01\
    \x0b\x11\n\r\n\x05\x04\n\x02\x06\x01\x12\x04\x9d\x01\x12\x1c\n\r\n\x05\
    \x04\n\x02\x06\x03\x12\x04\x9d\x01\x1f\x20b\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(3);
            deps.push(::protobuf::well_known_types::timestamp::file_descriptor().clone());
            deps.push(::protobuf::well_known_types::empty::file_descriptor().clone());
            deps.push(::protobuf::well_known_types::wrappers::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(11);
            messages.push(AuthenticateWithSocialAccountRequest::generated_message_descriptor_data());
            messages.push(GetCollegesResponse::generated_message_descriptor_data());
            messages.push(GetCountriesResponse::generated_message_descriptor_data());
            messages.push(ValidateAccessTokenResponse::generated_message_descriptor_data());
            messages.push(LoginRequest::generated_message_descriptor_data());
            messages.push(RegisterRequest::generated_message_descriptor_data());
            messages.push(ResetPasswordRequest::generated_message_descriptor_data());
            messages.push(Account::generated_message_descriptor_data());
            messages.push(AccessTokenStore::generated_message_descriptor_data());
            messages.push(Country::generated_message_descriptor_data());
            messages.push(College::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(1);
            enums.push(UserType::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
